<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Li Qingyao</title>
    <description>Hello World</description>
    <link>http://code.liqingyao.com/</link>
    <atom:link href="http://code.liqingyao.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 28 Aug 2016 16:48:15 +0800</pubDate>
    <lastBuildDate>Sun, 28 Aug 2016 16:48:15 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>CSS Flex Layout 算法解析</title>
        <description>&lt;p&gt;实现 Web-Native 混合开发已有很多知名开源框架，包括 Facebook 的 &lt;a href=&quot;http://reactnative.cn/&quot;&gt;React-Native&lt;/a&gt;， 阿里的 &lt;a href=&quot;http://alibaba.github.io/weex/&quot;&gt;Weex&lt;/a&gt;， GeekZoo 的 &lt;a href=&quot;https://github.com/hackers-painters/samurai-native&quot;&gt;Samurai-Native&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/gavinkwoe/BeeFramework&quot;&gt;Bee-Framework&lt;/a&gt;。其实现各有差异和特色，React-Native 采用 JSX + JS + CSS 技能栈，为前端开发者向移动端迁移这一路径提供了解决方案。与 React-Native 侧重 JS 端不同的是，Samurai-Native 的原生端更重，采用 W3C 标准 HTML + CSS + JS，更倾向于为移动端开发者向前端开发迁移这一路径提供解决方案。无论何种框架，要实现通过用网页的规范或自定义的模板规范来达到动态控制原生 UI，都会包含以下过程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;HTML 或模板解析，构建 DOM 树&lt;/li&gt;
  &lt;li&gt;CSS 样式解析，并转换为原生系统属性&lt;/li&gt;
  &lt;li&gt;动态数据解析及注入&lt;/li&gt;
  &lt;li&gt;从 DOM 树构建渲染树&lt;/li&gt;
  &lt;li&gt;对渲染树各节点应用样式，并计算布局&lt;/li&gt;
  &lt;li&gt;对渲染树各节点绑定事件，实现 JS 和原生方法之间的互相调用&lt;/li&gt;
  &lt;li&gt;从渲染树生成视图，最终显示&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;布局是承上启下的中间环节，渲染树是从 DOM 树映射而来的可布局的层级关系，通过应用布局属性确定视图排版。React-Native 和 Weex 的核心布局算法都采用 Facebook 开源的 &lt;a href=&quot;https://github.com/facebook/css-layout&quot;&gt;CSSLayout&lt;/a&gt; 算法，CSSLayout 基于 &lt;a href=&quot;https://www.w3.org/TR/css-flexbox-1/&quot;&gt;W3C 标准的 Flexbox 模型&lt;/a&gt;对页面元素排版，同时也支持相对布局和绝对布局，iOS 和 Andriod 平台都适用。把布局和视图生成两部分从整个架构中抽离出来，也可成为客户端 UI 框架，比如 Facebook 的 &lt;a href=&quot;http://componentkit.org/&quot;&gt;ComponentKit&lt;/a&gt; 和 &lt;a href=&quot;http://asyncdisplaykit.org/&quot;&gt;AsyncDisplayKit&lt;/a&gt;，前者用 React 的思路通过描述性、可组合的组件实现视图层，后者极大程度的优化了布局、渲染等操作，大大提高了帧率。因此布局不仅是起承转合的环节，更是性能的瓶颈所在，需要非常扎实的功底，灵活运用缓存、线程切换等手段来优化性能。水很深，慢慢学习，先从布局算法开始。&lt;/p&gt;

&lt;p&gt;CSSLayout 基于 Flexbox 模型，对容器可应用以下属性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FlexDirection&lt;/li&gt;
  &lt;li&gt;FlexWrap&lt;/li&gt;
  &lt;li&gt;JustifiyContent&lt;/li&gt;
  &lt;li&gt;AlignItems&lt;/li&gt;
  &lt;li&gt;AlignContent&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对元素可应用以下属性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Flex&lt;/li&gt;
  &lt;li&gt;AlignSelf&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了 Flex 属性，还支持普通的 Position 和 Overflow 属性。&lt;/p&gt;

&lt;p&gt;CSSLayout 按照 &lt;a href=&quot;(https://www.w3.org/TR/css-flexbox-1/)&quot;&gt;CSS Flexbox 标准&lt;/a&gt;建议的流程计算布局，主要步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对特殊节点和情况进行预处理：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1.1 文本节点：采用 measure 方法，通过回调视图对文本实际计算得到的尺寸确定宽高&lt;/p&gt;

&lt;p&gt;1.2 叶子节点：直接求解，不进行递归计算&lt;/p&gt;

&lt;p&gt;1.3 不执行布局计算的节点：直接求解&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;确定节点内每个子节点的 FlexBasis&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对节点内所有子节点遍历，对元素分行并计算主轴和交叉轴对齐&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3.1 将子节点分行&lt;/p&gt;

&lt;p&gt;3.2 计算当前行内元素在主轴上的尺寸，计算当前行剩余可分配空间&lt;/p&gt;

&lt;p&gt;3.3 计算当前行内元素在主轴上的位置，计算当前行内元素在交叉轴上的尺寸&lt;/p&gt;

&lt;p&gt;3.4 计算当前行内元素在交叉轴上的位置&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;计算节点的多行对齐，更新元素在交叉轴上的位置&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;计算节点的最终尺寸和位置&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;计算绝对定位子节点的尺寸和位置&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置子节点的 trailing 位置&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section&quot;&gt;准备&lt;/h3&gt;

&lt;h4 id=&quot;section-1&quot;&gt;样式和布局属性&lt;/h4&gt;

&lt;p&gt;一个对象的布局由位置和尺寸这两个要素唯一确定，但实际使用中我们很少用这种赋绝对值的思维来指定排版，而是通过指定相对位置、相对宽高、相互关系来间接实现，所以布局要做的就是从这些相对信息中推算出每个对象的绝对信息，通过多次从根节点开始向下遍历，以及从子节点向上回溯，不断估计、修正，计算出树上每个节点的唯一布局。&lt;/p&gt;

&lt;p&gt;计算过程中用到的样式属性包括：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://code.liqingyao.com/images/style-properties.png&quot; alt=&quot;style-properties&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;主轴 &lt;code class=&quot;highlighter-rouge&quot;&gt;mainAxis&lt;/code&gt; 以及垂直于主轴方向的交叉轴 &lt;code class=&quot;highlighter-rouge&quot;&gt;crossAxis&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;外边距 &lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;、边框 &lt;code class=&quot;highlighter-rouge&quot;&gt;border&lt;/code&gt;、内边距 &lt;code class=&quot;highlighter-rouge&quot;&gt;padding&lt;/code&gt;，这三个边距都分别包括 &lt;code class=&quot;highlighter-rouge&quot;&gt;left&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;top&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;right&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;bottom&lt;/code&gt; 四个方向的值，可以分别指定。需要注意的是，对象的实际尺寸 &lt;code class=&quot;highlighter-rouge&quot;&gt;width&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;height&lt;/code&gt; 是除去 &lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt; 后的部分，而在计算过程中，一个对象内部的计算尺寸是除去 &lt;code class=&quot;highlighter-rouge&quot;&gt;border&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;padding&lt;/code&gt; 后的部分。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;leading&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;trailing&lt;/code&gt; 是另一种访问上面三个边距的方式，根据 &lt;code class=&quot;highlighter-rouge&quot;&gt;FlexDirection&lt;/code&gt; 属性分别对应不同边缘的边距值，&lt;code class=&quot;highlighter-rouge&quot;&gt;leading-left&lt;/code&gt; 在行排列 &lt;code class=&quot;highlighter-rouge&quot;&gt;Row&lt;/code&gt; 时对应 &lt;code class=&quot;highlighter-rouge&quot;&gt;left&lt;/code&gt; 边缘，在列排列 &lt;code class=&quot;highlighter-rouge&quot;&gt;Column&lt;/code&gt; 时对应 &lt;code class=&quot;highlighter-rouge&quot;&gt;top&lt;/code&gt; 边缘，在逆向行排列 &lt;code class=&quot;highlighter-rouge&quot;&gt;RowReverse&lt;/code&gt; 时对应 &lt;code class=&quot;highlighter-rouge&quot;&gt;right&lt;/code&gt; 边缘，在逆向列排列 &lt;code class=&quot;highlighter-rouge&quot;&gt;Column-Reverse&lt;/code&gt; 时对应 &lt;code class=&quot;highlighter-rouge&quot;&gt;bottom&lt;/code&gt; 边缘。&lt;/li&gt;
  &lt;li&gt;对象的边界可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;minWidth&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;minHeight&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;maxWidth&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;maxHeight&lt;/code&gt; 来指定，当基于 &lt;code class=&quot;highlighter-rouge&quot;&gt;FlexGrow&lt;/code&gt; 扩展和 &lt;code class=&quot;highlighter-rouge&quot;&gt;FlexShrink&lt;/code&gt; 压缩时作为边界的约束条件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;布局算法把外部传入的计算属性先转化为对应的数组，通过下标访问具体值，而下标又是通过主轴、交叉轴构造的映射关系表来获取。比如在四种 &lt;code class=&quot;highlighter-rouge&quot;&gt;FlexDirection&lt;/code&gt; 模式下，&lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;left&lt;/code&gt; 值可以统一用 &lt;code class=&quot;highlighter-rouge&quot;&gt;margin[leading[mainAxis]]&lt;/code&gt; 来表示。&lt;/p&gt;

&lt;p&gt;计算过程中用到的布局属性包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;位置 &lt;code class=&quot;highlighter-rouge&quot;&gt;position&lt;/code&gt;，包括 &lt;code class=&quot;highlighter-rouge&quot;&gt;left&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;top&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;right&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;bottom&lt;/code&gt; 四个定位值&lt;/li&gt;
  &lt;li&gt;尺寸 &lt;code class=&quot;highlighter-rouge&quot;&gt;dimension&lt;/code&gt;，包括 &lt;code class=&quot;highlighter-rouge&quot;&gt;width&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;height&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;估计尺寸 &lt;code class=&quot;highlighter-rouge&quot;&gt;measuredDimension&lt;/code&gt;，包括 &lt;code class=&quot;highlighter-rouge&quot;&gt;width&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;height&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;measuredDimension&lt;/code&gt; 是计算过程中的中间变量，几次迭代后得到最终的 &lt;code class=&quot;highlighter-rouge&quot;&gt;dimension&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;布局模式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;未定义 &lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureModeUndified&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;精确 &lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureModeExactly&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;至多 &lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureModeAtMost&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;布局模板&lt;/h4&gt;

&lt;p&gt;文章中用下面的排版来解析布局算法：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://code.liqingyao.com/images/layout-result.png&quot; alt=&quot;layout-result&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;最外层是一个 Flex 容器对象，内部包含四个 Flex 元素对象和一个绝对布局对象，容器对象定宽 &lt;code class=&quot;highlighter-rouge&quot;&gt;600px&lt;/code&gt;，高度由内部对象决定，同时规定了主轴、&lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;padding&lt;/code&gt;，以及一些对齐方式：行排列、元素可换行、主轴起点对齐、交叉轴起点对齐、多行时沿交叉轴两端对齐&lt;/li&gt;
  &lt;li&gt;内部第一个元素定宽 &lt;code class=&quot;highlighter-rouge&quot;&gt;300px&lt;/code&gt;，高度由内容决定，实际可能是一个 Label、TextField 或者 ImageView；第二个元素定高 &lt;code class=&quot;highlighter-rouge&quot;&gt;100px&lt;/code&gt;，上下外边距各 &lt;code class=&quot;highlighter-rouge&quot;&gt;40px&lt;/code&gt;，扩展比例系数为 &lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;，压缩比例系数为 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;；第三个元素定义最小宽度 &lt;code class=&quot;highlighter-rouge&quot;&gt;100px&lt;/code&gt;，扩展和压缩比例系数都为 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;，并规定自己沿交叉轴拉伸对齐；第四个元素定宽 &lt;code class=&quot;highlighter-rouge&quot;&gt;200px&lt;/code&gt;，高度由内部子元素决定&lt;/li&gt;
  &lt;li&gt;最后一个绝对布局对象定义其距离父对象的右边距和下边距各 &lt;code class=&quot;highlighter-rouge&quot;&gt;10px&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-3&quot;&gt;预处理&lt;/h3&gt;

&lt;p&gt;算法首先对内容节点、叶子节点和非布局节点这三种情况进行预处理，提前返回，减少走完整个流程的次数，尽可能的减少计算量。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://code.liqingyao.com/images/xmind-precalculating.png&quot; alt=&quot;xmind-precalculating&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;内容节点&lt;/h4&gt;

&lt;p&gt;对 &lt;code class=&quot;highlighter-rouge&quot;&gt;Label&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;TextField&lt;/code&gt; 等文本节点和 &lt;code class=&quot;highlighter-rouge&quot;&gt;ImageView&lt;/code&gt; 等由内容决定的节点直接通过外部传入的 measure 回调拿到尺寸。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;layoutNode&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt; 方法可以通过协议让具体的视图来实现：&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;CGSize&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;CGFloat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;measure&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;no&quot;&gt;CGSize&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;measure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;CGFloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objc_getAssociatedObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;measure&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;__weak&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;typeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wself&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;measure&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;CGSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;CGFloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;__strong&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;typeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wself&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sself&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wself&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;no&quot;&gt;CGFloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isnan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sself&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sizeThatFits&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:CGSizeMake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;MAXFLOAT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setMeasure&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:measure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;measure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;引用 &lt;code class=&quot;highlighter-rouge&quot;&gt;layoutNode&lt;/code&gt; 的上下文可以拿到其绑定视图的 &lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt; 方法：&lt;/p&gt;

&lt;p&gt;内容节点宽高的取值由外部传入的布局模式决定，精确模式下内容节点的尺寸就是外部传入的宽高，未定义和至多模式下尺寸由 &lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt; 回调的宽高确定，同时要保证内部尺寸非负。&lt;/p&gt;

&lt;p&gt;为了比较清晰的阐明思路，只列出了宽度的计算表达式。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;叶子节点&lt;/h4&gt;

&lt;p&gt;对没有孩子的叶子节点，由于不需要递归计算内部子节点的布局，因此可以直接通过指定的模式算出估计尺寸，跳过接下来的流程。&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;非布局节点&lt;/h4&gt;

&lt;p&gt;同样，在对布局树的多次递归过程中，对于只需知道子节点尺寸而不需要知道位置的情况，会把 &lt;code class=&quot;highlighter-rouge&quot;&gt;performLayout&lt;/code&gt; 标志位置为 &lt;code class=&quot;highlighter-rouge&quot;&gt;NO&lt;/code&gt; 来跳过计算量消耗较大的计算位置的流程。&lt;/p&gt;

&lt;p&gt;可以看到，容器中第一个元素的宽高已经确定。&lt;/p&gt;

&lt;h3 id=&quot;flexbasis&quot;&gt;确定 flexBasis&lt;/h3&gt;

&lt;p&gt;这一步确定容器中每个子元素的在主轴上的 &lt;code class=&quot;highlighter-rouge&quot;&gt;flexBasis&lt;/code&gt; 值。&lt;code class=&quot;highlighter-rouge&quot;&gt;flexBasis&lt;/code&gt; 是每个元素的在未扩展和压缩前的基准尺寸，父容器用来计算主轴的剩余空间，然后根据扩展和压缩比例系数为每个 Flex 子元素调整尺寸。由于绝对定位子节点不参与 Flex 布局，因此不需要计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;flexBasis&lt;/code&gt; 值，在这一步中，会先把绝对定位子节点存储在链表中，在 Flex 布局完成后再单独计算所有绝对定位节点的布局。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://code.liqingyao.com/images/xmind-flexbasis.png&quot; alt=&quot;xmind-flexbasis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于相对定位子节点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果样式中直接规定了主轴尺寸，则 &lt;code class=&quot;highlighter-rouge&quot;&gt;flexBasis&lt;/code&gt; 直接被指定，这里还会将尺寸和 &lt;code class=&quot;highlighter-rouge&quot;&gt;padding + border&lt;/code&gt; 的尺寸比较，限定 FlexBasis 值不能小于内边距和边框长度&lt;/li&gt;
  &lt;li&gt;如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;flexBasis &amp;lt;= 0&lt;/code&gt; 并且内部主轴尺寸未定义，则 &lt;code class=&quot;highlighter-rouge&quot;&gt;flexBasis = 0&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;其他情况则通过估计子节点内部元素的尺寸来确定，这里首先会估算子节点的宽高并确定对应的估计模式：&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3.1 样式中定义了宽高：直接使用定义的值，且指定模式为 `MeasureModeExactly`

3.2 交叉轴尺寸未定义：根据标准，在未定义交叉轴尺寸的情况下，默认等于由外部指定的最大可用尺寸，并且指定模式是 `MeasureModeAtMost`

3.3 交叉轴拉伸对齐：交叉轴尺寸为最大可用尺寸，且指定模式为 `MeasureModeExactly`
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后调用 layout 函数递归估算内部节点在主轴上所占用的尺寸，并赋值给 &lt;code class=&quot;highlighter-rouge&quot;&gt;flexBasis&lt;/code&gt;
   layout 函数&lt;/p&gt;

&lt;p&gt;这步中可以得到容器中第一个元素 &lt;code class=&quot;highlighter-rouge&quot;&gt;flexBasis = 300px&lt;/code&gt;，第二个元素 &lt;code class=&quot;highlighter-rouge&quot;&gt;flexBasis = padding + border&lt;/code&gt;，第三个元素 &lt;code class=&quot;highlighter-rouge&quot;&gt;flexBasis = 100px&lt;/code&gt;，第四个元素 &lt;code class=&quot;highlighter-rouge&quot;&gt;flexBasis = 200px&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;单行计算&lt;/h3&gt;

&lt;p&gt;这一步骤是一个大循环体，首先遍历容器中所有子节点，按照上一步中计算出的 &lt;code class=&quot;highlighter-rouge&quot;&gt;flexBasis&lt;/code&gt; 对超过容器可用主轴尺寸的节点分行，接着对每行分别计算各节点经过 flexible 后的尺寸并更新剩余可分配空间。之后根据主轴对齐方式调整各元素在主轴上的位置并计算交叉轴尺寸，最后根据交叉轴对齐方式计算元素的交叉轴位置。&lt;/p&gt;

&lt;h4 id=&quot;section-8&quot;&gt;元素分行&lt;/h4&gt;

&lt;p&gt;这一步是一个内部循环体，对相对布局元素累加当前消耗的主轴尺寸和该元素的 &lt;code class=&quot;highlighter-rouge&quot;&gt;flexBasis&lt;/code&gt;，如果超过可用主轴尺寸且容器支持换行，则表示占满一行并跳出内循环。循环体中：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;累加当前行所消耗的主轴尺寸 &lt;code class=&quot;highlighter-rouge&quot;&gt;sizeConsumedOnCurrentLine += flexBasis + margin&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;累加扩展系数 &lt;code class=&quot;highlighter-rouge&quot;&gt;flexGrowFactors += flexGrow&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;累加压缩比例系数 &lt;code class=&quot;highlighter-rouge&quot;&gt;flexShrinkScaledFactors += flexShrink * flexBasis&lt;/code&gt;，注意 Flex 中定义压缩比例是相对于子节点的主轴尺寸而言，因此压缩系数需要乘 &lt;code class=&quot;highlighter-rouge&quot;&gt;flexBasis&lt;/code&gt; 后再累加&lt;/li&gt;
  &lt;li&gt;把节点保存到相对布局节点链表中，之后进行布局&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;到这里可以确定容器分为两行，第一行 &lt;code class=&quot;highlighter-rouge&quot;&gt;sizeConsumedOnCurrentLine = &lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;flexGrowFactors = 3&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;flexGrowFactors = 3&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;主轴尺寸计算&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;计算初始剩余可分配空间&lt;/li&gt;
  &lt;li&gt;初步计算子节点的主轴 flex 尺寸，主要处理触发边界限制的元素&lt;/li&gt;
&lt;/ol&gt;

  	2.1 经 flex 扩展和压缩后，对触发边界限制的元素使用边界条件，比如元素扩展后的尺寸大于 &lt;code class=&quot;highlighter-rouge&quot;&gt;maxWidth&lt;/code&gt; 限制，则元素的主轴尺寸为 &lt;code class=&quot;highlighter-rouge&quot;&gt;maxWidth&lt;/code&gt;

  	2.2 累加触发边界限制元素的修正空间 &lt;code class=&quot;highlighter-rouge&quot;&gt;deltaFreeSpace&lt;/code&gt;、修正扩展系数 &lt;code class=&quot;highlighter-rouge&quot;&gt;deltaFlexGrowFactors&lt;/code&gt; 和修正压缩比例系数 &lt;code class=&quot;highlighter-rouge&quot;&gt;deltaFlexShrinkScaledFactors&lt;/code&gt;

  	2.3 剔除触发边界限制的元素，并更新剩余可分配空间和扩展压缩系数

&lt;ol&gt;
  &lt;li&gt;重新计算子节点的主轴 flex 尺寸&lt;/li&gt;
  &lt;li&gt;确定子节点主轴尺寸及估计模式：主轴尺寸为子节点主轴 flex 尺寸加上外边距尺寸，并规定模式为 &lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureModeExactly&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;确定子节点交叉轴尺寸及估计模式：&lt;/li&gt;
  &lt;li&gt;第二次调用 layout 	方法，递归计算子节点内部节点的主轴 flex 尺寸&lt;/li&gt;
  &lt;li&gt;最后更新容器内的剩余空间&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;到这里四个元素的主轴尺寸已经计算完毕。&lt;/p&gt;

&lt;h4 id=&quot;section-10&quot;&gt;主轴位置计算及交叉轴尺寸计算&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;对主轴估计模式为 &lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureModeAtMost&lt;/code&gt; 的情况，清空剩余空间&lt;/li&gt;
  &lt;li&gt;根据容器的 &lt;code class=&quot;highlighter-rouge&quot;&gt;JustifyContent&lt;/code&gt; 属性计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;leadingMainDim&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;betweenMainDim&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对本行内元素依次计算主轴位置 &lt;code class=&quot;highlighter-rouge&quot;&gt;posotion[mainAxis] = mainDim&lt;/code&gt;，并更新 &lt;code class=&quot;highlighter-rouge&quot;&gt;mainDim&lt;/code&gt; 和初步计算 &lt;code class=&quot;highlighter-rouge&quot;&gt;crossDim&lt;/code&gt;：
  3.1 对非 layout 节点：&lt;code class=&quot;highlighter-rouge&quot;&gt;mainDim += betweenMainDim + margin + flexBasis&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;crossDim&lt;/code&gt; 为外部设定的可用尺寸
  3.2 对 layout 节点： &lt;code class=&quot;highlighter-rouge&quot;&gt;mainDim += betweenMainDim + margin + measureDim&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;crossDim&lt;/code&gt; 为本行元素最大交叉轴尺寸&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;确定本行交叉轴尺寸&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-11&quot;&gt;交叉轴位置计算&lt;/h4&gt;

&lt;h3 id=&quot;section-12&quot;&gt;多行计算&lt;/h3&gt;

&lt;h3 id=&quot;section-13&quot;&gt;确定尺寸和位置&lt;/h3&gt;

&lt;h3 id=&quot;section-14&quot;&gt;绝对定位&lt;/h3&gt;

&lt;h3 id=&quot;trailing-&quot;&gt;Trailing 赋值&lt;/h3&gt;

&lt;h3 id=&quot;section-15&quot;&gt;缓存机制&lt;/h3&gt;
</description>
        <pubDate>Sun, 21 Aug 2016 00:32:32 +0800</pubDate>
        <link>http://code.liqingyao.com/flex-layout-algorithm-introduction/</link>
        <guid isPermaLink="true">http://code.liqingyao.com/flex-layout-algorithm-introduction/</guid>
        
        
        <category>WebNative</category>
        
      </item>
    
      <item>
        <title>Jekyll 个人静态博客建站及优化</title>
        <description>&lt;p&gt;写博客要追溯到高中，用百度空间记录生活和想法，坚持了四年多，直到大二时被盗号，申诉多次没有追回帐号，就没再写过。研二重整旗鼓，买了域名和服务，在 WordPress 上搭了个人博客，想模仿牛人写些技术博客。最近在面试时，面试官提到了我的博客，建议我用 GitHub 和 Jekyll 建站试试，于是我就开始捯饬着搬迁和建立工作。&lt;/p&gt;

&lt;p&gt;发现自己经历了&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html&quot;&gt;阮一峰&lt;/a&gt;说的写博客的三个阶段:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;第一阶段，刚接触 Blog，觉得很新鲜，试着选择一个免费空间来写。&lt;/p&gt;

  &lt;p&gt;第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。&lt;/p&gt;

  &lt;p&gt;第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从零开始搭博客挺好玩，也可以趁此机会学一些前端。按照&lt;a href=&quot;http://beiyuu.com/github-pages/&quot;&gt;教程&lt;/a&gt;一步步走完后，博客初见规模。要做到更好还要考虑性能优化、网站分析和其他功能，有很多可以挖掘的，完全看个人喜好和发挥。当然最重要还是内容。弄完后才知道一篇华丽丽的牛人博客，其实很花心思！相关的建站教程很多，我就结合自己的建站过程整理下思路，有兴趣的也可以直接在 Github 上 clone。&lt;/p&gt;

&lt;p&gt;###&lt;strong&gt;确定环境和架构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. &lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用 GitHub 托管博客的好处是方便查看和共享、轻量级、干净简单、还可以绑定域名。配合 Jekyll / Hexo / Ghost 等博客系统站内生成网页，直接在本地 repo 更新、发布博客，可以更专注于码字。&lt;/p&gt;

&lt;p&gt;首先去官网看一下文档：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://help.github.com/categories/github-pages-basics/&quot;&gt;基础教程&lt;/a&gt;主要看一下 Pages 的用法、怎么用 Jekyll 和配置域名&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://help.github.com/categories/github-pages-features/&quot;&gt;进阶版&lt;/a&gt;了解下 Pages 还有订阅、表情、重定向、Sitemap 等功能和插件&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2. &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对&lt;a href=&quot;http://www.zhihu.com/question/21981094&quot;&gt;博客系统的讨论&lt;/a&gt;很多，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Hexo：基于 Node.js，因为文章生成速度快、操作简单、命令精简而受欢迎；本地直接生成网页上传 Github&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Jekyll：基于 Ruby；Github 原生，上传到 Github 后自动转换成网页；据说 Geek 更喜欢 Jekyll， 所以就选了它&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接着去 Jekyll 官网看一下文档：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;搞清楚&lt;a href=&quot;http://jekyllrb.com/docs/structure/&quot;&gt;文件目录框架&lt;/a&gt;和&lt;a href=&quot;http://jekyllrb.com/docs/frontmatter/&quot;&gt;语法元素&lt;/a&gt;的用法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;了解 Jekyll 还可以安装许多插件&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3. 站点结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;GitHub 支持&lt;a href=&quot;https://help.github.com/articles/user-organization-and-project-pages/&quot;&gt;两种形式的 Pages&lt;/a&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;User &amp;amp; Organization Pages：&lt;/p&gt;

    &lt;p&gt;为每个用户准备的主页，通过建立名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt; 的 repo 激活，建立后可通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;http(s)://&amp;lt;username&amp;gt;.github.io&lt;/code&gt; 访问；&lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt; 是 Github 用户名，每个用户只能建一个，内容在 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支修改和提交。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Project Pages：&lt;/p&gt;

    &lt;p&gt;为 Github 项目准备的描述页面，博客也可使用这种形式配置模板、发布内容；用户可以建多个 Project Pages，新建 &lt;code class=&quot;highlighter-rouge&quot;&gt;gh-pages&lt;/code&gt; 分支并在里面修改和提交，可通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;http(s)://&amp;lt;username&amp;gt;.github.io/&amp;lt;projectname&amp;gt;&lt;/code&gt; 访问。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GitHub 支持两种形式自定义域名：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Apex domains(一级域名)：在 DNS 提供商也就是 Godady 上修改 A 记录指向 GitHub 的 IP&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Subdomains(二级域名)：在 Godaddy 上申请一个 CNAME 记录&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我参考了&lt;a href=&quot;http://http://www.wileam.com&quot;&gt;Wileam&lt;/a&gt;组织结构，一级域名作为网站导航，博客、project等子项目分别建在二级域名上，方便管理和分类、可以灵活用不同主题，也防止 &lt;a href=&quot;http://myweb.jowai.info/bind-subdomain-on-godaddy-for-github-pages/&quot;&gt;Github 不再支持直接指向 IP 地址的 A Host 导致没法查看文章&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;架构如下：&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img width=&quot;420px&quot; height=&quot;180px&quot; src=&quot;/images/structure.png&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;分别建立 repo:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;一级域名用 &lt;code class=&quot;highlighter-rouge&quot;&gt;User &amp;amp; Organization Pages&lt;/code&gt;，直接在 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支 commit&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;二级域名用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Project Pages&lt;/code&gt;，新建并在&lt;code class=&quot;highlighter-rouge&quot;&gt;gh-pages&lt;/code&gt;分支 commit&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;###&lt;strong&gt;绑定域名&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 购买域名&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在 &lt;a href=&quot;https://www.godaddy.com/&quot;&gt;godaddy&lt;/a&gt; 上挑一个没被注册的域名，付钱搞定。一般第一次付款的折扣力度比较大，可以一下多买几年。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. &lt;a href=&quot;https://help.github.com/articles/tips-for-configuring-an-a-record-with-your-dns-provider/&quot;&gt;绑定一级域名&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;配置 Godaddy：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;配置 A 记录：每个域名只有一个 A 记录，修改 A 记录指向 IP 地址 &lt;code class=&quot;highlighter-rouge&quot;&gt;192.30.252.153&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;192.30.252.154&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置 www 子域名：新建或修改 www 的 CNAME 记录，指向 A 记录，这样有无 www 的两个网站就能相互跳转&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;配置本地 repo：向根目录添加或修改 CNAME 文件，内容为自己的一级域名 &lt;code class=&quot;highlighter-rouge&quot;&gt;domain&lt;/code&gt;, 此时浏览器输入一级域名就能实现跳转&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. &lt;a href=&quot;http://myweb.jowai.info/bind-subdomain-on-godaddy-for-github-pages/&quot;&gt;绑定二级域名&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;配置 Godaddy Zone File:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;添加一条 Record，选择 CNAME(Alias)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;填写 Host 为二级域名，并指向自己的一级域名&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;配置本地 repo:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;向根目录添加或修改 CNAME 文件，内容为自己的二级域名 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;subdomain&amp;gt;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改根目录 &lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt; 配置文件中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;url: http://&amp;lt;subdomain&amp;gt;.&amp;lt;domain&amp;gt;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###&lt;strong&gt;运行起来&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. &lt;a href=&quot;http://jekyllrb.com/docs/installation/&quot;&gt;安装 Jekyll&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://ruby.taobao.org/&quot;&gt;安装 Ruby / Rubygems &lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ gem install jekyll&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2. 选个喜欢的模板&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;主页：在 &lt;a href=&quot;http://www.free-css.com/free-css-templates&quot;&gt;Free CSS&lt;/a&gt; 上找单页模板，下载到一级域名对应 repo 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;博客：在 &lt;a href=&quot;http://jekyllthemes.org/&quot;&gt;Jekyll Themes&lt;/a&gt; 上直接下载，或者用 GitHub &lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt; 到二级域名对应 repo 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;gh-pages&lt;/code&gt;分支&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3. 预览&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;本地预览：&lt;code class=&quot;highlighter-rouge&quot;&gt;$ jekyll serve&lt;/code&gt;，浏览器输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:4000&lt;/code&gt; 本地预览模板效果&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;提交看效果：&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;，页面生效后就能浏览看，看看你的模板在移动端的 Responsive 能力好不好&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;4. 发布第一篇博文&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; 下新建名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-artical-title&lt;/code&gt; 的 MarkDown 文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://sspai.com/25137&quot;&gt;MarkDown 语法说明&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;###&lt;strong&gt;其他自定义及优化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 修改模板&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;小修小改：背景图片、字体、主题颜色、添加 favicon&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加模块： About、Categories&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有用的网站：&lt;a href=&quot;http://blog.javachen.com/2013/08/31/my-jekyll-config.html&quot;&gt;修改大全&lt;/a&gt;； &lt;a href=&quot;https://www.google.com/fonts&quot;&gt;Google 字体&lt;/a&gt;； &lt;a href=&quot;http://fontawesome.dashgame.com/&quot;&gt;Font Awesome 图标字体库&lt;/a&gt;；&lt;a href=&quot;http://www.ifreesite.com/color/color-code-converter.htm&quot;&gt;色码转换器&lt;/a&gt;； &lt;a href=&quot;http://rgb.phpddt.com/&quot;&gt;色彩对照表&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2. 增加功能&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://blog.masr.in/geek/add_comment_to_jekyll.html&quot;&gt;Disqus 评论模块&lt;/a&gt;：Jekyll 不支持数据库，评论模块需要另装，&lt;a href=&quot;https://disqus.com/&quot;&gt;Disqus&lt;/a&gt; 和 国内的&lt;a href=&quot;http://duoshuo.com/&quot;&gt;多说&lt;/a&gt;都不错&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://codingtips.kanishkkunal.in/share-buttons-jekyll/&quot;&gt;页内分享&lt;/a&gt;：除了自己写链接代码外，分享到国内社交平台还可以用&lt;a href=&quot;http://share.baidu.com/code/&quot;&gt;百度分享&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.google.com/analytics/&quot;&gt;Google Analytics&lt;/a&gt;：关心博客访问量和流量分析的话，可以安装 Google Analystics 或者&lt;a href=&quot;http://tongji.baidu.com/web/welcome/login&quot;&gt;百度统计&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://zyzhang.github.io/blog/2012/08/31/highlight-with-Jekyll-and-Pygments/&quot;&gt;代码高亮&lt;/a&gt;：MarkDown 原生的代码块没有高亮，可以用 Pygments 选择喜欢的主题，生成 CSS 样式，引用到自己的模板中&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3. &lt;a href=&quot;http://jekyll.tips/tutorials/seo/&quot;&gt;SEO 网站优化&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SEO（Search Engine Optimize) 是专为 Google 或 百度小爬虫能有效找到博客的优化方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;优化博客标题和描述：用形如 &lt;code class=&quot;highlighter-rouge&quot;&gt;page.title&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;page.description&lt;/code&gt; 这样的标签，而不是 Hard Code，方便修改&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;优化 URL 结构：用 Permalink  改写博客 URL，最好是以标题关键词的形式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://cn.yizeng.me/2013/05/26/create-a-custom-jekyll-404-page/&quot;&gt;自定义 404.html&lt;/a&gt;：设置 404 错误页面，把失效或者无效的博客地址引导到主页&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加 Sitemap.xml： Sitemap 包含站点结构和博客标题、最近修改时间等内容信息，方便搜索引擎找到&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://vdaubry.github.io/2014/10/21/SEO-for-your-Jekyll-blog/&quot;&gt;其他尚未使用的方法&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后，感谢我的两个模板 &lt;a href=&quot;https://github.com/mojombo/tpw&quot;&gt;TPW&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/nandomoreirame/zetsu&quot;&gt;Zetsu&lt;/a&gt; 让我省了很多力 :D&lt;/p&gt;
</description>
        <pubDate>Fri, 20 Nov 2015 23:34:32 +0800</pubDate>
        <link>http://code.liqingyao.com/bulid-personal-blog/</link>
        <guid isPermaLink="true">http://code.liqingyao.com/bulid-personal-blog/</guid>
        
        
        <category>其他</category>
        
      </item>
    
      <item>
        <title>搭建工作环境</title>
        <description>&lt;p&gt;十月中旬校招结束，确定了一桩大事后，放慢了拼命赶路的脚步，列了很多 TODO list，不过还得先从打造一个顺手的工作平台和学习环境开始。
所谓工欲善其事，必先利其器 &amp;amp; 磨刀不误砍柴工。虽然这些都成了不写论文的借口，但经历了一个多月的打磨，总算初见规模。尽管望尘莫及牛人的体系方法，好歹也是迈出了第一步。&lt;/p&gt;

&lt;p&gt;###&lt;strong&gt;同步系统&lt;/strong&gt;
&lt;strong&gt;1. 重要资料同步 - &lt;a href=&quot;https://www.dropbox.com/&quot;&gt;Dropbox&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;重要资料的定义：钻研多年的学术成果、源代码；记录每一阶段的文档、文件等重要等级高的内容。&lt;/p&gt;

&lt;p&gt;dropbox 是非常好的同步平台：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;安全可靠&lt;/strong&gt; - 不用怕哪天突然被告知数据清空&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;同步速度快&lt;/strong&gt; - 对修改的文件上传增量部分而不是重传整个文件，在大文件上进行小修改的性能超过许多同质产品&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外两个特点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;需要翻墙&lt;/strong&gt; - 每次要同步时要需要翻墙&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;容量限制&lt;/strong&gt; - 普通用户初始 2G 空间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;修改重要文件时一般在电脑前，所以我在 Mac 和 Windows 上装了客户端，其他情况可以直接通过 Web 版访问。Dropbox 的使用习惯比较容易养成，就此摆脱了用 U 盘颠来倒去的无谓折腾。&lt;/p&gt;

&lt;p&gt;Tips：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;刷容量&lt;/strong&gt; - 拜托好友帮个忙呗！~&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;共享文件夹&lt;/strong&gt; - 利用好共享文件夹，省去通过邮件或者 QQ 频繁互传文件的烦恼，据说还有异地情侣用共享文件夹来传情呢~&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他奇巧淫技：&lt;a href=&quot;http://www.zhihu.com/question/20104959&quot;&gt;看看其他大神怎么把 Dropbox 用彻底&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 大文件、非重要资料同步 - 百度云盘&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;百度云盘的特征正好和 Dropbox 互补，墙内人民不需要翻墙、容量无限制（尽管有一次性传输大小限制），但安全性和同步速度略逊色。那么正好用它的特点来保存一些重要等级低但经常需要同步访问的内容，比如软件、音视图；或者用作于文件共享。&lt;/p&gt;

&lt;p&gt;资料的同步，尤其是用 Dropbox 时，我认为它并不是资料的最终宿主，当一个阶段结束后，比如项目交付了、毕业了，这些资料处于静止状态不会修改时，存到硬盘归档，给新文件腾出空间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 代码同步 + 托管 - Git&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于个人代码的同步必须 Git 啊，话不多说，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;公开的代码&lt;/strong&gt; - Github&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;私有的代码&lt;/strong&gt; - BitBucket&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;###&lt;strong&gt;笔记系统&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如何记笔记，一个看似简单的问题。其实是时间安排、记录、整合、运用等等能力的总和，说白了就是如何学习，而学习的习惯贯穿职业生涯、伴随一生。之前我是豪放派，想到就写，要记录就随手拿一张 A4 纸，东一榔头西一棒子，很多草稿都留着，看着乱也没什么大用，扔了又舍不得，总之剪不断理还乱。而好的习惯就能把零碎的知识点串联起来，转换成自己知识体系的一部分。因此在这变与不变之际，痛下决心纠正好。&lt;/p&gt;

&lt;p&gt;首先来看看牛人们都是怎么说的：&lt;a href=&quot;http://www.zhihu.com/question/23427617/answer/28206585&quot;&gt;如何构建自己的笔记系统？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 任务派发&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;有明确的学习目标 - &lt;a href=&quot;http://www.xmindchina.net/&quot;&gt;XMind&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;每个阶段都应该都一个中等规模的学习目标，掌握某项专业技能、学习一个新的领域等等，不以职业生涯的改变而改变的学习计划。这种学习方式第一步可以利用 XMind 建立思维导图，明确知识脉络。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;项目驱动 - &lt;a href=&quot;https://trello.com/&quot;&gt;Trello&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;项目驱动任务的特征是一上手可能没有非常清晰的脉络，可能涉及到许多未知的知识点，需要在行进中学习；或者项目提出的任务比较分散；在跟进中遇到许多突发问题等，同时也常常是工作中接受任务时的情况。可以参考下图 GCD 模型 (Get Things Done Model) 来管理任务清单，对应的软件有许多，包括 doit.im 等等。我选择了知乎中提到的 Trello，简单直接。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://code.liqingyao.com/images/GTDcanonical.png&quot; alt=&quot;GTDcanonical&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2. 资料收集 - Pocket / 收藏夹 / Evernote&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;网页看了还没整理的 -&amp;gt; 收藏夹&lt;/li&gt;
  &lt;li&gt;网页愈看未看的 -&amp;gt; Pocket&lt;/li&gt;
  &lt;li&gt;收藏夹和 Pocket 里的 -&amp;gt; Evernote Inbox&lt;/li&gt;
  &lt;li&gt;突发奇想的 -&amp;gt; Evernote Inbox&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;资料来源五花八门，看上去比较杂，但最后各路小溪都汇聚到印象笔记的 Inbox 里，等待再一次消化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 整理整合 - Evernote&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每周一整理，Inbox 里零碎的片段分门别类放到笔记本中&lt;/li&gt;
  &lt;li&gt;每月一整合，归并、整合笔记本中的笔记&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;4. 归档&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;经过了三次消化，笔记中的内容已经成为自己的囊中之物。和文件系统最终的归档一样，知识要经过归档才能形成更有价值的内容，以博客或社区回答的形式共享出去，授人以渔的同时自己会收获更多。&lt;/p&gt;

&lt;p&gt;好了，说了那么多，实践和坚持最重要!&lt;/p&gt;

&lt;!-- ### 工具箱

磨刀还需磨刀棒，实用小工具不光用得顺手，干活效率那也是杠杠的。

- Beyond Compare

  两年前从导师那里知道的文件比对工具，代码比较、二进制文件比较、文件同步，谁用谁知道，简直是神器。

- Atom

- Markdown

- 快捷键

- 键盘 --&gt;
</description>
        <pubDate>Fri, 20 Nov 2015 23:34:32 +0800</pubDate>
        <link>http://code.liqingyao.com/build-working-environment/</link>
        <guid isPermaLink="true">http://code.liqingyao.com/build-working-environment/</guid>
        
        
        <category>其他</category>
        
      </item>
    
      <item>
        <title>Windows下安装与使用GCC编译器</title>
        <description>&lt;p&gt;###&lt;strong&gt;什么是GCC?&lt;/strong&gt;
我们在Windows系统下习惯使用诸如Windows Visual Stdio图形化IDE工具来编辑和编译代码，但在Unix/Linux系统下如何编译C++代码呢？答案是GCC(GUN Compiler Collection)。GCC源于一场自由软件计划，最初只能在不同操作系统上处理C语言，经过快速扩张后目前也支持C++/Objective-C/Java/Ada/Pascal/Fortran等多种语言的编译。&lt;/p&gt;

&lt;p&gt;###&lt;strong&gt;安装GCC&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;下载安装MinGW
MinGW(Minimalist GNU on Windows)是Windows系统下GNU工具套装，使用MinGW来安装GCC。
&lt;a href=&quot;http://sourceforge.net/projects/mingw/files/&quot;&gt;点击下载&lt;/a&gt;，并安装到C盘根目录。&lt;/li&gt;
  &lt;li&gt;配置Windows环境变量
找到环境变量：控制面板-&amp;gt;系统-&amp;gt;高级系统设置-&amp;gt;高级-&amp;gt;环境变量；
在系统变量中选择&lt;code&gt;Path&lt;/code&gt;，并在变量值中添加&lt;code&gt;C:\MinGW\bin&lt;/code&gt;
在系统变量中新建&lt;code&gt;LIBRARY_PATH&lt;/code&gt;，变量值是&lt;code&gt;C:\MinGW\lib&lt;/code&gt;
在系统变量中新建&lt;code&gt;C_INCLUDE_PATH&lt;/code&gt;，变量值是&lt;code&gt;C:\MinGW\include&lt;/code&gt;
以上操作分别配置了标准库和头文件的存放路径。&lt;/li&gt;
  &lt;li&gt;使用MinGW安装GCC
运行MinGW,在Basic Setup中选择mingw32-gcc-g++
选择Installation-&amp;gt;Apply Changes
等待GCC相关环境安装完毕。&lt;/li&gt;
  &lt;li&gt;以上步骤完成后，在cmd敲入命令
&lt;code&gt;gcc --version&lt;/code&gt;
如果安装成功，会显示gcc版本号。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###&lt;strong&gt;使用GCC&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;创建GCC工作目录
&lt;code&gt;mkdir CPP&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;前往工作目录
&lt;code&gt;cd CPP&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;选择一种文本编辑器（比如Windows自带的notepad）
&lt;code&gt;notepad main.c&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在自动弹出的文本编辑器中敲测试代码，保存&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;kp&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;stdlib.h&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Hello World&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;!-- &lt;pre class=&quot;theme:github width-set:true width:450 lang:default decode:true &quot; &gt;include &amp;lt;stdio.h&amp;gt;
include &amp;lt;stdlib.h&amp;gt;
int main() {
    printf(&quot;Hello World\n&quot;);
    return(0);
}&lt;/pre&gt; --&gt;

&lt;ol&gt;
  &lt;li&gt;使用GCC编译main.c，输出HelloWorld可执行文件
&lt;code&gt;gcc main.c -o HelloWorld&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;此时会报错“缺少libgcc_s_sjlj-1.dll文件”
&lt;a href=&quot;http://www.dll-files.com/dllindex/dll-files.shtml?libgcc_s_sjlj-1&quot;&gt;点击下载&lt;/a&gt;32-bit版本，解压并放到C:\Windows\SysWOW64中&lt;/li&gt;
  &lt;li&gt;重复步骤5，正常运行，此时可以看到工作目录下生成了HelloWorld.exe文件。最后在cmd中运行文件
&lt;code&gt;HelloWorld.exe&lt;/code&gt;
终于看到第一个测试输出“HelloWorld”，大功告成！&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;[参考资料]&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;http://www.wikihow.com/Compile-a-C-Program-Using-the-GNU-Compiler-(GCC)&lt;/li&gt;
	&lt;li&gt;http://blog.csdn.net/firefoxbug/article/details/6724876&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 22 Apr 2015 18:21:32 +0800</pubDate>
        <link>http://code.liqingyao.com/windows-install-gcc/</link>
        <guid isPermaLink="true">http://code.liqingyao.com/windows-install-gcc/</guid>
        
        
        <category>其他</category>
        
      </item>
    
      <item>
        <title>如何成为更好的 iOS 开发者</title>
        <description>&lt;p&gt;在 Boss 的敦促和项目进度的高压下猛学了两个多月 iOS 开发，从 Objective-C 小白到上线第一个应用，再到反思技术改进应用。从始至终都是自学，回头看看确实走了不少弯路。在这做些小总结，也希望能给读者带来些许帮助。&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;零基础自学方法论：先概览后细节，先容易后复杂。参考资料和步骤如下：&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;&lt;a href=&quot;http://rypress.com/tutorials/objective-c/index.html&quot;&gt;Ry’s Objective-C Tutorial&lt;/a&gt; （图形化教学，深入浅出）&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://v.163.com/special/opencourse/iphonekaifa.html&quot;&gt;iPhone 开发公开课：CS193P&lt;/a&gt; （高富帅轮番上阵，不学也难）&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://www.raywenderlich.com/&quot;&gt;Ray Wenderlich Tutorial&lt;/a&gt; 或者 &lt;a href=&quot;http://www.techotopia.com/index.php/Image:Ios_7_app_development_essentials.png&quot;&gt;Techotopia Tutorial&lt;/a&gt;  或者 &lt;a href=&quot;http://www.appcoda.com/tutorials/&quot;&gt;AppCoda Tutorial&lt;/a&gt;（入门基础控件/TableView/ViewController 等用法的好教程，丰富的示例，三者可以结合使用）&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/navigation/&quot;&gt;iOS Developer Library&lt;/a&gt;（万能的百科全书，初学者最好有以上基础后再参考）&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/&quot;&gt;StackOverflow&lt;/a&gt;（高质量论坛，或者直接 google 搜索关键词：[problem] + ios / [problem] + iPhone SDK 找 StackOverflow 的链接）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我就是按照以上思路来自学的。接下来需要掌握以下：&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;a href=&quot;http://www.raywenderlich.com/46988/ios-design-patterns&quot;&gt;iOS Design Pattern&lt;/a&gt;（Cocoa 核心架构：MVC）&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;https://www.codefellows.org/blog/everything-a-competent-ios-developer-needs-to-know&quot;&gt;Everything a Competent iOS Developer Needs to Know&lt;/a&gt;（iOS 开发树形结构）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一条是 iOS App 架构指南针，深入理解 Design Pattern 是写出结构清晰、维护方便、可重用性高的代码的核心，也是每一个 iOS 开发者必须知道的事。&lt;/p&gt;

&lt;p&gt;第二条的 iOS 树形图囊括了一个高素质 iOS 开发者需要必备的知识储备。&lt;/p&gt;

&lt;p&gt;当你对以上都了然于心，也有了一些实战经验后，比如开发过一两个完整的 App，是不是觉得代码的堆砌造成很难维护和修改，想学更多又不知从何下手。我现在也正经历这个阶段。我找了一些方法，与君共勉。&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;阅读大量高质量开源代码（from Github），也让他人来阅读你的代码&lt;/li&gt;
	&lt;li&gt;宁愿多花时间来思考架构和模块的规划，也不要立刻埋头码字&lt;/li&gt;
	&lt;li&gt;为代码写注释，组织好代码结构&lt;/li&gt;
	&lt;li&gt;不断的练习（Do you know the rule of 10,000? It says that if you want to be world-class in any field you have to invest 10,000 hours in total.）&lt;/li&gt;
	&lt;li&gt;阅读 iOS 牛人博客，关注苹果发布会等新动态，同时关心一切互联网、科技新闻，保持一颗年轻的心。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[参考资料]&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;http://www.wikihow.com/Improve-your-Skills-as-a-Programmer&lt;/li&gt;
	&lt;li&gt;http://www.appdesignvault.com/betterdeveloper/&lt;/li&gt;
	&lt;li&gt;http://www.cocoanetics.com/2010/07/how-to-become-great-at-ios-development/&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 14 Nov 2014 02:56:32 +0800</pubDate>
        <link>http://code.liqingyao.com/how-to-become-better-ios-developer/</link>
        <guid isPermaLink="true">http://code.liqingyao.com/how-to-become-better-ios-developer/</guid>
        
        
        <category>iOS</category>
        
      </item>
    
  </channel>
</rss>
