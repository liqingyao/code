<!DOCTYPE html> <html lang="pt-br"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title> CSS Flex Layout 算法解析 </title> <meta name="description" content="实现 Web-Native 混合开发已有很多知名开源框架，包括 Facebook 的 React-Native， 阿里的 Weex， GeekZoo 的 Samurai-Native 和 Bee-Framework。其实现各有差异和特色，React-Native 采用 JSX + JS + CSS 技能栈，为前端..."> <link rel="stylesheet" href="/css/main.css"> <link rel="canonical" href="http://code.liqingyao.com/flex-layout-algorithm-introduction/"> <link rel="alternate" type="application/rss+xml" title="Li Qingyao" href="http://code.liqingyao.com/feed.xml" /> <script type="text/javascript"> var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-52446115-1']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })(); </script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-70794446-1', 'code.liqingyao.com'); ga('send', 'pageview'); </script> <meta name="robots" content="noindex"> <!--===== Please remove it ! ! ! ======--> <meta name="googlebot" content="noindex"> <!--===== Please remove it ! ! ! ======--> </head> <body class="flex-layout-algorithm-introduction"> <main class="main"> <header class="header"> <div class="overlay"> <div class="container"> <h1 class="title"> <a href="http://liqingyao.com">Li Qingyao</a> </h1> <nav class="navbar"> <a href="#" class="menu-icon"> <span></span> <span></span> <span></span> </a> <ul class="nav"> <li><a href="/about/">About</a></li> <li><a href="/categories/">Categories</a></li> <li><a href="/">Home</a></li> </ul> </nav> </div> <!-- --> </div> </header> <article class="post container card"> <header class="post-header"> <h1 class="post-title">CSS Flex Layout 算法解析</h1> <span class="post-meta"> <time class="post-date" datetime="2016-08-21">Aug 21, 2016</time> <span class="post-author"> &bull; in WebNative</span> </span> </header> <div class="post-content"> <p>实现 Web-Native 混合开发已有很多知名开源框架，包括 Facebook 的 React-Native， 阿里的 Weex， GeekZoo 的 Samurai-Native 和 Bee-Framework。其实现各有差异和特色，React-Native 采用 JSX + JS + CSS 技能栈，为前端开发者向移动端迁移这一路径提供了解决方案。与 React-Native 侧重 JS 端不同的是，Samurai-Native 的原生端更重，采用 W3C 标准 HTML + CSS + JS，更倾向于为移动端开发者向前端开发迁移这一路径提供解决方案。无论何种框架，要实现通过用网页的规范或自定义的模板规范来达到动态控制原生 UI，都会包含以下过程：</p> <ol> <li>HTML 或模板解析，构建 DOM 树</li> <li>CSS 样式解析，并转换为原生系统属性</li> <li>动态数据解析及注入</li> <li>从 DOM 树构建渲染树</li> <li>对渲染树各节点应用样式，并计算布局</li> <li>对渲染树各节点绑定事件，实现 JS 和原生方法之间的互相调用</li> <li>从渲染树生成视图，最终显示</li> </ol> <p>布局是承上启下的中间环节，渲染树是从 DOM 树映射而来的可布局的层级关系，通过应用布局属性确定视图排版。React-Native 和 Weex 的核心布局算法都采用 Facebook 开源的 CSSLayout 算法，CSSLayout 基于 W3C 标准的 Flexbox 模型对页面元素排版，同时也支持相对布局和绝对布局，iOS 和 Andriod 平台都适用。把布局和视图生成两部分从整个架构中抽离出来，也可成为客户端 UI 框架，比如 Facebook 的 ComponentKit 和 AsyncDisplayKit，前者用 React 的思路通过描述性、可组合的组件实现视图层，后者极大程度的优化了布局、渲染等操作，大大提高了帧率。因此布局不仅是起承转合的环节，更是性能的瓶颈所在，需要非常扎实的功底，灵活运用缓存、线程切换等手段来优化性能。水很深，慢慢学习，先从布局算法开始。</p> <p>CSSLayout 基于 Flexbox 模型，对容器类可应用以下属性：</p> <ul> <li>FlexDirection</li> <li>FlexWrap</li> <li>JustifiyContent</li> <li>AlignItems</li> <li>AlignContent</li> </ul> <p>对元素类可应用以下属性：</p> <ul> <li>Flex</li> <li>AlignSelf</li> </ul> <p>CSSLayout 除了 Flex 属性外，还可支持：</p> <ul> <li>Position</li> <li>Overflow</li> </ul> <p>CSSLayout 按照 CSS Flexbox 标准建议的流程计算布局，主要步骤：</p> <ol> <li>对特殊节点和情况进行预处理：</li> </ol> <div class="highlighter-rouge"><pre class="highlight"><code>1.1 文本节点：采用 measure 方法，通过回调视图对文本实际计算得到的尺寸确定宽高

1.2 叶子节点：直接求解，不进行递归计算

1.3 不执行 layout 计算的节点：直接求解
</code></pre></div> <ol> <li>确定节点内每个子节点的 FlexBasis</li> <li>对节点内所有子节点遍历，对元素分行并计算主轴和交叉轴对齐</li> </ol> <div class="highlighter-rouge"><pre class="highlight"><code>3.1 将子节点分行

3.2 计算当前行内元素在主轴上的尺寸，计算当前行剩余可分配空间

3.3 计算当前行内元素在主轴上的位置，计算当前行内元素在交叉轴上的尺寸

3.4 计算当前行内元素在交叉轴上的位置   4. 计算节点的多行对齐，更新元素在交叉轴上的位置   5. 计算节点的最终尺寸和位置   6. 计算绝对定位子节点的尺寸和位置   7. 设置子节点的 trailing 位置
</code></pre></div> <h3 id="section">准备</h3> <h4 id="section-1">1. 变量</h4> <p>一个对象的布局由位置和尺寸这两个要素唯一确定，但实际使用中我们很少用这种赋绝对值的思维来指定排版，而是通过指定相对位置、相对宽高、相互关系来间接实现，所以布局要做的就是从这些相对信息中推算出每个对象的绝对信息，通过多次从根节点开始向下遍历，以及从子节点向上回溯，不断估计、修正，计算出树上每个节点的唯一布局。</p> <p>计算过程中用到的样式属性包括：</p> <ol> <li>主轴 <code class="highlighter-rouge">mainAxis</code> 以及垂直于主轴方向的交叉轴 <code class="highlighter-rouge">crossAxis</code></li> <li>外边距 <code class="highlighter-rouge">margin</code>、边框 <code class="highlighter-rouge">border</code>、内边距 <code class="highlighter-rouge">padding</code>，这三个边距都分别包括 <code class="highlighter-rouge">left</code>、<code class="highlighter-rouge">top</code>、<code class="highlighter-rouge">right</code>、<code class="highlighter-rouge">bottom</code> 四个方向的值，可以分别指定。需要注意的是，对象的实际尺寸 <code class="highlighter-rouge">width</code> 和 <code class="highlighter-rouge">height</code> 是除去 <code class="highlighter-rouge">margin</code> 后的部分，而在计算过程中，一个对象内部的计算尺寸是除去 <code class="highlighter-rouge">border</code> 和 <code class="highlighter-rouge">padding</code> 后的部分。</li> <li><code class="highlighter-rouge">leading</code> 和 <code class="highlighter-rouge">trailing</code> 是另一种访问上面三个边距的方式，根据 <code class="highlighter-rouge">FlexDirection</code> 属性分别对应不同边缘的边距值，<code class="highlighter-rouge">leading-left</code> 在行排列 <code class="highlighter-rouge">Row</code> 时对应 <code class="highlighter-rouge">left</code> 边缘，在列排列 <code class="highlighter-rouge">Column</code> 时对应 <code class="highlighter-rouge">top</code> 边缘，在逆向行排列 <code class="highlighter-rouge">RowReverse</code> 时对应 <code class="highlighter-rouge">right</code> 边缘，在逆向列排列 <code class="highlighter-rouge">Column-Reverse</code> 时对应 <code class="highlighter-rouge">bottom</code> 边缘。</li> <li>对象的边界可以通过 <code class="highlighter-rouge">minWidth</code>、<code class="highlighter-rouge">minHeight</code>、<code class="highlighter-rouge">maxWidth</code>、<code class="highlighter-rouge">maxHeight</code> 来指定，当基于 <code class="highlighter-rouge">FlexGrow</code> 扩展和 <code class="highlighter-rouge">FlexShrink</code> 压缩时作为边界的约束条件。</li> </ol> <p>布局算法把外部传入的计算属性先转化为对应的数组，通过下标访问具体值，而下标又是通过主轴、交叉轴构造的映射关系表来获取。比如在四种 <code class="highlighter-rouge">FlexDirection</code> 模式下，<code class="highlighter-rouge">margin</code> 的 <code class="highlighter-rouge">left</code> 值可以统一用 <code class="highlighter-rouge">margin[leading[mainAxis]]</code> 来表示。</p> <p>计算过程中用到的布局属性包括：</p> <ol> <li>位置 <code class="highlighter-rouge">position</code>，包括 <code class="highlighter-rouge">left</code>、<code class="highlighter-rouge">top</code>、<code class="highlighter-rouge">right</code>、<code class="highlighter-rouge">bottom</code> 四个定位值</li> <li>尺寸 <code class="highlighter-rouge">dimension</code>，包括 <code class="highlighter-rouge">width</code> 和 <code class="highlighter-rouge">height</code></li> <li>估计尺寸 <code class="highlighter-rouge">measuredDimension</code>，包括 <code class="highlighter-rouge">width</code> 和 <code class="highlighter-rouge">height</code>，<code class="highlighter-rouge">measuredDimension</code> 是计算过程中的中间变量，几次迭代后得到最终的 <code class="highlighter-rouge">dimension</code></li> </ol> <p>布局模式：</p> <ol> <li>未定义</li> <li>精确</li> <li>至多</li> </ol> <h4 id="section-2">2. 布局效果</h4> <p>首先定义排版对象：</p> <ol> <li>最外层是一个 Flex 容器对象，内部包含四个 Flex 元素对象和一个绝对布局对象，容器对象定宽 <code class="highlighter-rouge">600px</code>，高度由内部对象决定，同时规定了主轴、<code class="highlighter-rouge">margin</code> 和 <code class="highlighter-rouge">padding</code>，以及一些对齐方式：行排列、元素可换行、主轴起点对齐、交叉轴起点对齐、多行时沿交叉轴两端对齐</li> <li>内部第一个元素定宽 <code class="highlighter-rouge">300px</code>，高度由内容决定，实际可能是一个 Label、TextField 或者 ImageView；第二个元素定高 <code class="highlighter-rouge">100px</code>，上下外边距各 <code class="highlighter-rouge">40px</code>，扩展比例系数为 <code class="highlighter-rouge">2</code>，压缩比例系数为 <code class="highlighter-rouge">1</code>；第三个元素定义最小宽度 <code class="highlighter-rouge">100px</code>，扩展和压缩比例系数都为 <code class="highlighter-rouge">1</code>，并规定自己沿交叉轴拉伸对齐；第四个元素定宽 <code class="highlighter-rouge">200px</code>，高度由内部子元素决定</li> <li>最后一个绝对布局对象定义其距离父对象的右边距和下边距各 <code class="highlighter-rouge">10px</code></li> </ol> <p>布局后的效果图：</p> <p>接下来就来解析算法如何一步步计算得到最终的布局</p> <h3 id="section-3">预处理</h3> <p>算法首先对内容节点、叶子节点和非布局节点这三种情况进行预处理，提前返回，减少走完整个流程的次数，尽可能的减少计算量。 图 xmind-precalculating</p> <h4 id="section-4">1. 内容节点</h4> <p>对 <code class="highlighter-rouge">Label</code>、<code class="highlighter-rouge">TextField</code> 等文本节点和 <code class="highlighter-rouge">ImageView</code> 等由内容决定的节点直接通过外部传入的 measure 回调拿到尺寸。</p> <p><code class="highlighter-rouge">layoutNode</code> 的 <code class="highlighter-rouge">measure</code> 方法可以通过协议让具体的视图来实现： 图</p> <p>引用 <code class="highlighter-rouge">layoutNode</code> 的上下文可以拿到其绑定视图的 <code class="highlighter-rouge">measure</code> 方法： 图</p> <p>内容节点宽高的取值由外部传入的布局模式决定，精确模式下内容节点的尺寸就是外部传入的宽高，未定义和至多模式下尺寸由 <code class="highlighter-rouge">measure</code> 回调的宽高确定，同时要保证内部尺寸非负。 为了比较清晰的阐明思路，只列出了宽度的计算表达式。</p> <h4 id="section-5">2. 叶子节点</h4> <p>对没有孩子的叶子节点，由于不需要递归计算内部子节点的布局，因此可以直接通过指定的模式算出估计尺寸，跳过接下来的流程。</p> <h4 id="section-6">3. 非布局节点</h4> <p>同样，在对布局树的多次递归过程中，对于只需知道子节点尺寸而不需要知道位置的情况，会把 <code class="highlighter-rouge">performLayout</code> 标志位置为 <code class="highlighter-rouge">NO</code> 来跳过计算量消耗较大的计算位置的流程。</p> <p>可以看到，容器中第一个元素的宽高已经确定。</p> <h3 id="flexbasis">确定 flexBasis</h3> <p>这一步确定容器中每个子元素的在主轴上的 <code class="highlighter-rouge">flexBasis</code> 值。<code class="highlighter-rouge">flexBasis</code> 是每个元素的在未扩展和压缩前的基准尺寸，父容器用来计算主轴的剩余空间，然后根据扩展和压缩比例系数为每个 Flex 子元素调整尺寸。由于绝对定位子节点不参与 Flex 布局，因此不需要计算 <code class="highlighter-rouge">flexBasis</code> 值，在这一步中，会先把绝对定位子节点存储在链表中，在 Flex 布局完成后再单独计算所有绝对定位节点的布局。</p> <p>对于相对定位子节点：</p> <ol> <li>如果样式中直接规定了主轴尺寸，则 <code class="highlighter-rouge">flexBasis</code> 直接被指定，这里还会将尺寸和 <code class="highlighter-rouge">padding + border</code> 的尺寸比较，限定 FlexBasis 值不能小于内边距和边框长度</li> <li>如果 <code class="highlighter-rouge">flexBasis &lt;= 0</code> 并且内部主轴尺寸未定义，则 <code class="highlighter-rouge">flexBasis = 0</code></li> <li>其他情况则通过估计子节点内部元素的尺寸来确定，这里首先会估算子节点的宽高并确定对应的估计模式：</li> </ol> <div class="highlighter-rouge"><pre class="highlight"><code>3.1 样式中定义了宽高：直接使用定义的值，且指定模式为 `MeasureModeExactly`

3.2 交叉轴尺寸未定义：根据标准，在未定义交叉轴尺寸的情况下，默认等于由外部指定的最大可用尺寸，并且指定模式是 `MeasureModeAtMost`

3.3 交叉轴拉伸对齐：交叉轴尺寸为最大可用尺寸，且指定模式为 `MeasureModeExactly`
</code></pre></div> <p>然后调用 layout 函数递归估算内部节点在主轴上所占用的尺寸，并赋值给 <code class="highlighter-rouge">flexBasis</code> layout 函数</p> <p>这步中可以得到容器中第一个元素 <code class="highlighter-rouge">flexBasis = 300px</code>，第二个元素 <code class="highlighter-rouge">flexBasis = padding + border</code>，第三个元素 <code class="highlighter-rouge">flexBasis = 100px</code>，第四个元素 <code class="highlighter-rouge">flexBasis = 200px</code>。</p> <h3 id="section-7">单行计算</h3> <p>这一步骤是一个大循环体，首先遍历容器中所有子节点，按照上一步中计算出的 <code class="highlighter-rouge">flexBasis</code> 对超过容器可用主轴尺寸的节点分行，接着对每行分别计算各节点经过 flexible 后的尺寸并更新剩余可分配空间。之后根据主轴对齐方式调整各元素在主轴上的位置并计算交叉轴尺寸，最后根据交叉轴对齐方式计算元素的交叉轴位置。</p> <h4 id="section-8">1. 元素分行</h4> <p>这一步是一个内部循环体，对相对布局元素累加当前消耗的主轴尺寸和该元素的 <code class="highlighter-rouge">flexBasis</code>，如果超过可用主轴尺寸且容器支持换行，则表示占满一行并跳出内循环。循环体中：</p> <ol> <li>累加当前行所消耗的主轴尺寸 <code class="highlighter-rouge">sizeConsumedOnCurrentLine += flexBasis + margin</code></li> <li>累加扩展系数 <code class="highlighter-rouge">flexGrowFactors += flexGrow</code></li> <li>累加压缩比例系数 <code class="highlighter-rouge">flexShrinkScaledFactors += flexShrink * flexBasis</code>，注意 Flex 中定义压缩比例是相对于子节点的主轴尺寸而言，因此压缩系数需要乘 <code class="highlighter-rouge">flexBasis</code> 后再累加</li> <li>把节点保存到相对布局节点链表中，之后进行布局</li> </ol> <p>到这里可以确定容器分为两行，第一行 <code class="highlighter-rouge">sizeConsumedOnCurrentLine = </code> <code class="highlighter-rouge">flexGrowFactors = 3</code>，<code class="highlighter-rouge">flexGrowFactors = 3</code>。</p> <h4 id="section-9">2. 主轴尺寸计算</h4> <ol> <li>计算初始剩余可分配空间</li> <li>初步计算子节点的主轴 flex 尺寸，主要处理触发边界限制的元素</li> </ol> 2.1 经 flex 扩展和压缩后，对触发边界限制的元素使用边界条件，比如元素扩展后的尺寸大于 <code class="highlighter-rouge">maxWidth</code> 限制，则元素的主轴尺寸为 <code class="highlighter-rouge">maxWidth</code> 2.2 累加触发边界限制元素的修正空间 <code class="highlighter-rouge">deltaFreeSpace</code>、修正扩展系数 <code class="highlighter-rouge">deltaFlexGrowFactors</code> 和修正压缩比例系数 <code class="highlighter-rouge">deltaFlexShrinkScaledFactors</code> 2.3 剔除触发边界限制的元素，并更新剩余可分配空间和扩展压缩系数 <ol> <li>重新计算子节点的主轴 flex 尺寸</li> <li>确定子节点主轴尺寸及估计模式：主轴尺寸为子节点主轴 flex 尺寸加上外边距尺寸，并规定模式为 <code class="highlighter-rouge">MeasureModeExactly</code></li> <li>确定子节点交叉轴尺寸及估计模式：</li> <li>第二次调用 layout 方法，递归计算子节点内部节点的主轴 flex 尺寸</li> <li>最后更新容器内的剩余空间</li> </ol> <p>到这里四个元素的主轴尺寸已经计算完毕。</p> <h4 id="section-10">3. 主轴位置计算及交叉轴尺寸计算</h4> <ol> <li>对主轴估计模式为 <code class="highlighter-rouge">MeasureModeAtMost</code> 的情况，清空剩余空间</li> <li>根据容器的 <code class="highlighter-rouge">JustifyContent</code> 属性计算 <code class="highlighter-rouge">leadingMainDim</code> 和 <code class="highlighter-rouge">betweenMainDim</code></li> <li> <p>对本行内元素依次计算主轴位置 <code class="highlighter-rouge">posotion[mainAxis] = mainDim</code>，并更新 <code class="highlighter-rouge">mainDim</code> 和初步计算 <code class="highlighter-rouge">crossDim</code>： 3.1 对非 layout 节点：<code class="highlighter-rouge">mainDim += betweenMainDim + margin + flexBasis</code>，<code class="highlighter-rouge">crossDim</code> 为外部设定的可用尺寸 3.2 对 layout 节点： <code class="highlighter-rouge">mainDim += betweenMainDim + margin + measureDim</code>，<code class="highlighter-rouge">crossDim</code> 为本行元素最大交叉轴尺寸</p> </li> <li>确定本行交叉轴尺寸</li> </ol> <h4 id="section-11">4. 交叉轴位置计算</h4> <h3 id="section-12">多行计算</h3> <h3 id="section-13">确定尺寸和位置</h3> <h3 id="section-14">绝对定位</h3> <h3 id="trailing-">Trailing 赋值</h3> <h3 id="section-15">缓存机制</h3> <aside class="share"> <span>Share this to</span> <a href="http://twitter.com/share?text=CSS Flex Layout 算法解析&amp;url=http://code.liqingyao.com/flex-layout-algorithm-introduction/&amp;hashtags=web,dev,blog,soudev&amp;via=liqingyao"> <i class="fa fa-twitter-square"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?u=http://code.liqingyao.com/flex-layout-algorithm-introduction/"> <i class="fa fa-facebook-square"></i> </a> <a href="https://plus.google.com/share?url=http://code.liqingyao.com/flex-layout-algorithm-introduction/"> <i class="fa fa-google-plus-square"></i> </a> <a href="http://www.linkedin.com/shareArticle?mini=true&url=http://code.liqingyao.com/flex-layout-algorithm-introduction/&title=CSS Flex Layout 算法解析&summary=Li Qingyao&source=http://code.liqingyao.com"> <i class="fa fa-linkedin-square"></i> </a> <!-- <a href="https://plus.google.com/share?url=http://code.liqingyao.com/flex-layout-algorithm-introduction/"> <i class="fa fa-wechat"></i> </a> <a href="http://www.linkedin.com/shareArticle?mini=true&url=http://code.liqingyao.com/flex-layout-algorithm-introduction/&title=CSS Flex Layout 算法解析&summary=Li Qingyao&source=http://code.liqingyao.com"> <i class="fa fa-weibo"></i> </a> <a href="https://www.qq.com/share?url=http://code.liqingyao.com/flex-layout-algorithm-introduction/"> <i class="fa fa-qq"></i> </a> --> </aside> <hr> <aside id="comments" class="disqus"> <h2 class="txt-center">Comments</h2> <div id="disqus_thread"></div> <script type="text/javascript"> var disqus_shortname = 'codeliqingyao'; var disqus_identifier = '/flex-layout-algorithm-introduction'; var disqus_title = 'CSS Flex Layout 算法解析'; var disqus_url = 'http://code.liqingyao.com'; /*var disqus_developer = 1;*/ (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); </script> <noscript> Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a> </noscript> </aside> </div> </article> <footer class="footer t-center"> <div class="container"> <div class="social-icons"> <ul class="text-left"> <li><a href="https://github.com/liqingyao" target="_blank"><i class="fa fa-github"></i></a></li> <li><a href="http://weibo.com/leeleeannie" target="_blank"><i class="fa fa-weibo"></i></a></li> <li><a href="https://www.linkedin.com/in/liqingyao" target="_blank"><i class="fa fa-linkedin"></i></a></li> <li><a href="mailto:qingyao.li@yahoo.com" target="_blank"><i class="fa fa-envelope-o"></i></a></li> </ul> </div> <small>&copy; 2016 Li Qingyao. Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> and <i class="icon icon-heart"></i></small> <small>by <a href="http://nandomoreira.me" target="_blank">nandomoreira.me</a></small> </div> </footer> </main> </body> </html></body></html>
<!--
// # Zetsu Jekyll theme - https://github.com/nandomoreriame/zetsu/
// by nandomoreira.me
-->
