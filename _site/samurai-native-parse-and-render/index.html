<!DOCTYPE html> <html lang="pt-br"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title> Samurai-Native 解析及渲染原理 </title> <meta name="description" content="Samurai-Native"> <link rel="stylesheet" href="/css/main.css"> <link rel="canonical" href="http://code.liqingyao.com/samurai-native-parse-and-render/"> <link rel="alternate" type="application/rss+xml" title="Li Qingyao" href="http://code.liqingyao.com/feed.xml" /> <script type="text/javascript"> var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-52446115-1']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })(); </script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-70794446-1', 'code.liqingyao.com'); ga('send', 'pageview'); </script> </head> <body class="samurai-native-parse-and-render"> <main class="main"> <header class="header"> <div class="overlay"> <div class="container"> <h1 class="title"> <a href="http://liqingyao.com">Li Qingyao</a> </h1> <nav class="navbar"> <a href="#" class="menu-icon"> <span></span> <span></span> <span></span> </a> <ul class="nav"> <li><a href="/about/">About</a></li> <li><a href="/categories/">Categories</a></li> <li><a href="/">Home</a></li> </ul> </nav> </div> <!-- --> </div> </header> <article class="post container card"> <header class="post-header"> <h1 class="post-title">Samurai-Native 解析及渲染原理</h1> <span class="post-meta"> <time class="post-date" datetime="2016-11-21">Nov 21, 2016</time> <span class="post-author"> &bull; in WebNative</span> </span> </header> <div class="post-content"> <h2 id="samurai-native">Samurai-Native</h2> <p><a href="https://github.com/hackers-painters/samurai-native">Samurai-Native</a> 是 Hackers and Painters 出的第二款 Web-Native 框架，相对与其自家的第一款 <a href="https://github.com/gavinkwoe/BeeFramework">BeeFramework</a> 由 MVC、网络、文件系统等组成的大型框架而言，Samurai-Native 把动态 UI 下发的能力独立出来，用标准的 HTML + CSS + Javascript 技术栈提供一套混合开发的解决方案，相较而言更轻量级些，集成的成本相对低一些，是客户端开发向前端迁移的优秀方案之一。</p> <p>Samurai-Native 支持标准的 HTML 标签，框架内转化为客户端的 Native 控件，同时也支持在 HTML 模板里直接把 Native 的控件名作为标签使用。标签的 name 属性支持动态数据绑定，布局方面支持标准 CSS 和 Flexbox 布局，事件处理采用高大上的 Signal Handling。</p> <p>这篇文章主要撸了 Samurai-Native 框架解析及渲染部分的实现流程和原理，事件处理方面的机制暂时没有涉及。</p> <h3 id="section">整体流程</h3> <div align="center"> <img src="http://code.liqingyao.com/images/samurai-workflow.png" /> </div> <p><strong>1. 解析流程</strong></p> <ul> <li>上层业务启动后，加载模板到 document</li> <li>从 document 解析 HTML 资源文件，生成一棵从标签映射过来的 domTree</li> <li>从 document 解析 CSS 资源文件，默认样式表、link 的外部样式表、type=”text/css” 定义的外联样式表和标签 style 定义的内部样式表分别解析到 document 对应对象中</li> </ul> <p><strong>2. Reflow 流程</strong></p> <ul> <li>document 中样式有关对象合并到 styleSheet 对象中，以键值对形式按不同的类型（tag/id/class）保存在词典里</li> <li>处理 document 中外部导入的 HTML，把构成的 shadowTree 挂靠在相应 domTree 的节点上</li> </ul> <p><strong>3. 渲染流程</strong></p> <ul> <li>遍历 domTree 上每个节点（包括 shadowRoot），对不同来源的样式按照优先级依次添加到节点的 computedStyle 上，包括处理节点的继承样式，此时 的 computedStyle 还是以键值对形式存储样式，而且存的值仍然是字符串形式</li> <li>从 domTree 映射到 renderTree，这步中根据节点的类型（document/element/text）和节点的层次（tree/branch/leaf/hidden）生成相应的渲染对象，同时计算 computedStyle 中存储的值或者转换为 OC 对象（比如 UIColor）</li> </ul> <p><strong>4. 布局流程</strong></p> <ul> <li>创建视图</li> <li>视图布局</li> </ul> <h3 id="section-1">关键类结构</h3> <div align="center"> <img src="http://code.liqingyao.com/images/samurai-key-class-structure.png" /> </div> <p><strong>1. 祖先类 SamuraiTreeNode</strong></p> <ul> <li>Samurai-Native 框架中与 HTML/CSS/Render/Layout 相关类放在 samurai-webcore 文件目录下，其相关基础类放在 samurai-framework 文件目录下。</li> <li>SamuraiTreeNode 作为基石，放在 samurai-webcore 目录下，主要定义了树形结构创建及修改相关的一些方法。</li> </ul> <p><strong>2. 资源类</strong></p> <ul> <li>基类 SamuraiResource 继承自 SamuraiTreeNode，负责记录资源文件路径、内容等信息并提供一些初始化方法，同时也是 SamuraiDocument、SamuraiStyleSheet 和 SamuraiScript的父类，这三个类分别对应模板、样式表和脚本解析后的对象。</li> <li>SamuraiDocument 会持有一棵从 HTML 映射来的 domTree，一个树状样式表 styleTree、一棵渲染树 renderTree，以及保存着外部导入文件 externalImports、externalScripts、externalStyleSheets。</li> <li>Samurai 解析实际使用的是 SamuraiHtmlDocument、SamuraiCSSStyleSheet 两个类，SamuraiHtmlDocument、SamuraiCSSStyleSheet 持有样式规则集 SamuraiCSSRuleSet 对象和规则选择器 SamuraiCSSRuleCollector 对象。</li> </ul> <p><strong>3. 内部树类</strong></p> <ul> <li>SamuraiDomNode 和 SamuraiRenderObject 直接继承自 SamuraiTreeNode，分别对应 Document 里的 domTree 和 renderTree 树结构，前者记录节点的类型、属性、标签，还会弱引用一个 SamuraiDocument 对象，用来在任意时候获取自身 document 的一些信息。</li> <li>SamuraiDomNode 的子类 SamuraiHtmlDomNode 是框架中实际用到的 domTree 类型，持有用于实际计算样式的 computedStyle 样式和 shadowHost。</li> <li>SamuraiDomNode 的另一个子类 SamuraiRenderObject 弱引用他的 domNode，并持有一个 SamuraiRenderStyle 对象和一个用于实际展示的视图，他的子类 SamuraiHtmlRenderObject 是实际使用的类。</li> </ul> <p>接下来看一下流程对应的关键调用栈。</p> <h2 id="parse-workflow">Parse Workflow</h2> <h3 id="section-2">加载资源</h3> <div align="center"> <img src="http://code.liqingyao.com/images/samurai-load-timeline.png" /> </div> <p>服务启动后，经过层层调用最终会执行 NSObject 的 TemplateResponder 扩展类的方法，处理本地或者网络资源加</p> <div class="highlighter-rouge"><pre class="highlight"><code>- (void)loadTemplate:(NSString *)urlOrFile type:(NSString *)type
</code></pre></div> <p>上面的方法会对根据模板的资源路径和方式选择对应的加载方法，加载方法里先从 <code class="highlighter-rouge">SamuraiDocument</code> 父类调用创建一个相应子类的资源对象，然后解析他。比如从服务端下发的模板会调用 <code class="highlighter-rouge">SamuraiTemplate</code> 的方法</p> <div class="highlighter-rouge"><pre class="highlight"><code>- (void)loadURL:(NSString *)url type:(NSString *)type
</code></pre></div> <p>加载方法里首先调用 <code class="highlighter-rouge">SamuraiDocument</code> 的方法返回一个 document 资源对象</p> <div class="highlighter-rouge"><pre class="highlight"><code>+ (id)resourceWithURL:(NSString *)string type:(NSString *)type
</code></pre></div> <p>接下来会通过标志一些状态来告诉外部当前的状态，之后调用父类 <code class="highlighter-rouge">SamuraiResource</code> 的 <code class="highlighter-rouge">- (BOOL)parse</code> 方法根据资源的实际类型调用子类的解析方法，具体的解析流程接下类会分析</p> <p>完成解析工作后，通过 <code class="highlighter-rouge">SamuraiTemplate</code> 的</p> <div class="highlighter-rouge"><pre class="highlight"><code>- (void)handleResourceLoaded:(SamuraiResource *)resource
</code></pre></div> <p>方法处理资源加载后续工作，对 document 资源中的嵌套的子资源递归再走一遍上面的流程，直到 <code class="highlighter-rouge">resourceQueue</code> 中没有待加载的资源后，对 document 调用 <code class="highlighter-rouge">- (BOOL)reflow</code> 流程，具体的 reflow 过程拆分到下面分析。</p> <h3 id="html">解析 HTML</h3> <div align="center"> <img src="http://code.liqingyao.com/images/samurai-parse-timeline.png" /> </div> <p>资源的解析部分是整个框架的基础，这部分的重点在于把 HTML 文件解析为 domTree，把 CSS 文件解析为 styleSheet，并且需要具备处理各种来源资源的能力。Samurai-Native 这两部分分别用了 Google 的开源 HTML 解析器 Gumbo Parser 和 CSS 解析器 Katana Parser，两者的特点都是轻量级、外部依赖少、支持标准格式，足够在客户端使用。这里插一句，在对比了 Katana Parser 和 Netsurf 浏览器的内置 LibCSS Parser 之后，其实 Katana 只是解析器，Samurai-Native 自己处理了选择器的功能，性能会比 LibCSS 略逊一筹。</p> <p>接着看流程，加载资源完毕，<code class="highlighter-rouge">SamuraiResource</code> 调用 <code class="highlighter-rouge">- (BOOL)parse</code> 方法后，<code class="highlighter-rouge">SamuraiHtmlDocumentWorkflow_Parser</code> 根据上下文返回一个解析流程对象 <code class="highlighter-rouge">parserFlow</code>，然后调用他的 <code class="highlighter-rouge">- (BOOL)process</code> 方法，调用下面方法处理 workflow 中的每个 worklet</p> <div class="highlighter-rouge"><pre class="highlight"><code>- (BOOL)processWithContext:(SamuraiHtmlDocument *)document
</code></pre></div> <p>HTML 解析封装在 <code class="highlighter-rouge">SamuraiHtmlDocumentWorklet_20ParseDomTree</code> 类中，方法</p> <div class="highlighter-rouge"><pre class="highlight"><code>- (SamuraiHtmlDomNode *)parseHtml:(NSString *)html
</code></pre></div> <p>是解析 HTML 的入口，内部经过 Gumbo 解析器的处理，生成 <code class="highlighter-rouge">GumboOutput</code> 对象，通过递归访问他的节点构成 domTree 并返回。</p> <p>简单了解一下 <code class="highlighter-rouge">GumboOutput</code> 这个对象，</p> <ul> <li> <p><code class="highlighter-rouge">GumboOutput</code> 是文档解析后的输出对象，文档中的所有解析信息都用过这个数据结构间接访问，可以通过 <code class="highlighter-rouge">GumboNode</code> 类型的 <code class="highlighter-rouge">output-&gt;document</code> 访问文档对象</p> </li> <li> <p><code class="highlighter-rouge">GumboNode</code> 节点对象可以访问自己的类型，文档、元素、文本类型分别对应有一个 <code class="highlighter-rouge">GumboDocument</code>、 <code class="highlighter-rouge">GumboElement</code> 和 <code class="highlighter-rouge">GumboText</code> 对象，还可以访问自己的父节点和在兄弟节点中的位置</p> </li> <li> <p><code class="highlighter-rouge">GumboElement</code> 元素节点包括指向自己子节点的 <code class="highlighter-rouge">GumboVector</code> 对象，标签名 <code class="highlighter-rouge">GumboTag</code> 和 属性 <code class="highlighter-rouge">GumboVector</code> 等等</p> </li> </ul> <p>在解析方法中，递归调用</p> <div class="highlighter-rouge"><pre class="highlight"><code>- (void)parseChildren:(GumboNode *)node forParentNode:(SamuraiHtmlDomNode *)domNode
</code></pre></div> <p>解析子节点，在这个方法中，对不同类型的 <code class="highlighter-rouge">GumboNode</code> 分类讨论，比如对 <code class="highlighter-rouge">GUMBO_NODE_ELEMENT</code> 节点递归解析子节点，并把属性键值对存储在一个词典中；对 <code class="highlighter-rouge">GUMBO_NODE_TEXT</code> 节点只保存他的内容。</p> <h3 id="css">解析 CSS</h3> <p>CSS 解析部分接着看上面 timeline 的后半部分，之前说到 <code class="highlighter-rouge">SamuraiHtmlDocumentWorkflow_Parser</code> 遍历解析 parser 流程的每个 worklet，那么在处理完 <code class="highlighter-rouge">SamuraiHtmlDocumentWorklet_20ParseDomTree</code> 并得到成功解析的指令后，接下来会调用 <code class="highlighter-rouge">SamuraiHtmlDocumentWorklet_30ParseResource</code> 的方法解解析 CSS。</p> <div class="highlighter-rouge"><pre class="highlight"><code>- (BOOL)processWithContext:(SamuraiHtmlDocument *)document
</code></pre></div> <p>按照 HTML 解析的思路，CSS 解析也分别对 document、element、text 等类型分类讨论，document 节点是文档的父节点，只用于子节点的遍历，text 节点在 Gumbo 中被认为是用于保存文本内容的，并没有样式等属性，那么只有 element 元素的解析有实际作用。</p> <div class="highlighter-rouge"><pre class="highlight"><code>- (void)parseDomNodeElement:(SamuraiHtmlDomNode *)domNode forDocument:(SamuraiHtmlDocument *)document
</code></pre></div> <p>方法中根据 <code class="highlighter-rouge">domNode.tag</code> 分别解析样式文件，分类存储到文档的不同对象中，为不同时机的加载做准备</p> <ul> <li>外部和内部 styleSheet 资源保存在 <code class="highlighter-rouge">document.externalStyleSheets</code> 中</li> <li>外部链接的 import 资源保存在 <code class="highlighter-rouge">document.externalImports</code> 中</li> </ul> <p>样式和 <code class="highlighter-rouge">externalImports</code> 在遍历的时候便做了解析，分别调用下面函数触发，</p> <div class="highlighter-rouge"><pre class="highlight"><code>- (SamuraiStyleSheet *)parseStyleSheet:(SamuraiHtmlDomNode *)node basePath:(NSString * )basePath
- (SamuraiDocument *)parseImport:(SamuraiHtmlDomNode *)node basePath:(NSString * )basePath
</code></pre></div> <p>需要注意的是，在这两个解析方法中，按照资源的位置定义加载策略，比如 doucment 和 head 中引入的资源会第一时间预加载，而 body 中的资源会采用延时加载来提高初始化时候的解析速度。</p> <p>进一步挖掘样式解析调用会发现，在下一层次中，<code class="highlighter-rouge">SamuraiCSSStyleSheet</code> 调用 <code class="highlighter-rouge">- (BOOL)parse</code> 来实际解析样式文件。其内部调用 <code class="highlighter-rouge">SamuraiCSSParser</code> 单例方法</p> <div class="highlighter-rouge"><pre class="highlight"><code>- (KatanaOutput *)parseStylesheet:(NSString *)text
</code></pre></div> <p>把传入的资源内容解析为 Katana 解析器的输出对象 <code class="highlighter-rouge">KatanaOutput</code>，然后把解析出的规则添加到 <code class="highlighter-rouge">SamuraiCSSRuleSet</code> 集合对象中，这个对象会和 <code class="highlighter-rouge">SamuraiCSSRuleCollector</code> 联合选择出 domTree 上每个节点的样式，具体的规则放在渲染部分再分析。</p> <p>简单了解一下 <code class="highlighter-rouge">Katana</code> 的数据结构</p> <ul> <li> <p><code class="highlighter-rouge">KatanaOutput</code> 中的 <code class="highlighter-rouge">KatanaStyleSheet</code> 保存解析得到的样式表，内部由规则集组成</p> </li> <li> <p>每一条规则 <code class="highlighter-rouge">KatanaRule</code> 包含名字和规则类型（style/media/value/selector/declaration）<code class="highlighter-rouge">KatanaRuleType</code>，不同类型的规则有对应的数据结构去细化。我们这里主要看对 styleSheet 的解析。</p> </li> <li> <p><code class="highlighter-rouge">KatanaSelector</code> 数据结构中存储着用于匹配规则类型的 <code class="highlighter-rouge">KatanaSelectorMatch</code>，包括 tag/id/class/pseuduoClass等，在 <code class="highlighter-rouge">SamuraiCSSRuleSet</code> 中调用</p> </li> </ul> <div class="highlighter-rouge"><pre class="highlight"><code>- (BOOL)findBestRuleSetAndAddWithSelector:(KatanaSelector *)selector ruleData:(SamuraiCSSRule *)ruleData
</code></pre></div> <p>通过 <code class="highlighter-rouge">selector-&gt;match</code> 可以得到当前 rule 的匹配类型，对 styleSheet 解析得到的每个规则按匹配类型分门别类存放，用于之后分配各 domNode 的样式。</p> <p>Refolw 和渲染分析放在下一篇博客中。</p> <aside class="share"> <span>Share this to</span> <a href="http://twitter.com/share?text=Samurai-Native 解析及渲染原理&amp;url=http://code.liqingyao.com/samurai-native-parse-and-render/&amp;hashtags=web,dev,blog,soudev&amp;via=liqingyao"> <i class="fa fa-twitter-square"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?u=http://code.liqingyao.com/samurai-native-parse-and-render/"> <i class="fa fa-facebook-square"></i> </a> <a href="https://plus.google.com/share?url=http://code.liqingyao.com/samurai-native-parse-and-render/"> <i class="fa fa-google-plus-square"></i> </a> <a href="http://www.linkedin.com/shareArticle?mini=true&url=http://code.liqingyao.com/samurai-native-parse-and-render/&title=Samurai-Native 解析及渲染原理&summary=Li Qingyao&source=http://code.liqingyao.com"> <i class="fa fa-linkedin-square"></i> </a> <!-- <a href="https://plus.google.com/share?url=http://code.liqingyao.com/samurai-native-parse-and-render/"> <i class="fa fa-wechat"></i> </a> <a href="http://www.linkedin.com/shareArticle?mini=true&url=http://code.liqingyao.com/samurai-native-parse-and-render/&title=Samurai-Native 解析及渲染原理&summary=Li Qingyao&source=http://code.liqingyao.com"> <i class="fa fa-weibo"></i> </a> <a href="https://www.qq.com/share?url=http://code.liqingyao.com/samurai-native-parse-and-render/"> <i class="fa fa-qq"></i> </a> --> </aside> <hr> <aside id="comments" class="disqus"> <h2 class="txt-center">Comments</h2> <div id="disqus_thread"></div> <script type="text/javascript"> var disqus_shortname = 'codeliqingyao'; var disqus_identifier = '/samurai-native-parse-and-render'; var disqus_title = 'Samurai-Native 解析及渲染原理'; var disqus_url = 'http://code.liqingyao.com'; /*var disqus_developer = 1;*/ (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); </script> <noscript> Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a> </noscript> </aside> </div> </article> <footer class="footer t-center"> <div class="container"> <div class="social-icons"> <ul class="text-left"> <li><a href="https://github.com/liqingyao" target="_blank"><i class="fa fa-github"></i></a></li> <li><a href="http://weibo.com/leeleeannie" target="_blank"><i class="fa fa-weibo"></i></a></li> <li><a href="https://www.linkedin.com/in/liqingyao" target="_blank"><i class="fa fa-linkedin"></i></a></li> <li><a href="mailto:qingyao.li@yahoo.com" target="_blank"><i class="fa fa-envelope-o"></i></a></li> </ul> </div> <small>&copy; 2016 Li Qingyao. Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> and <i class="icon icon-heart"></i></small> <small>by <a href="http://nandomoreira.me" target="_blank">nandomoreira.me</a></small> </div> </footer> </main> </body> </html></body></html>
<!--
// # Zetsu Jekyll theme - https://github.com/nandomoreriame/zetsu/
// by nandomoreira.me
-->
