<!DOCTYPE html> <html lang="pt-br"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title> Samurai-Native 渲染及布局原理 </title> <meta name="description" content="接着上一篇博客 Samurai-Native 模板及样式解析原理"> <link rel="stylesheet" href="/css/main.css"> <link rel="canonical" href="http://code.liqingyao.com/samurai-native-render-workflow/"> <link rel="alternate" type="application/rss+xml" title="Li Qingyao" href="http://code.liqingyao.com/feed.xml" /> <script type="text/javascript"> var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-52446115-1']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })(); </script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-70794446-1', 'code.liqingyao.com'); ga('send', 'pageview'); </script> </head> <body class="samurai-native-render-workflow"> <main class="main"> <header class="header"> <div class="overlay"> <div class="container"> <h1 class="title"> <a href="http://liqingyao.com">Li Qingyao</a> </h1> <nav class="navbar"> <a href="#" class="menu-icon"> <span></span> <span></span> <span></span> </a> <ul class="nav"> <li><a href="/about/">About</a></li> <li><a href="/categories/">Categories</a></li> <li><a href="/">Home</a></li> </ul> </nav> </div> <!-- --> </div> </header> <article class="post container card"> <header class="post-header"> <h1 class="post-title">Samurai-Native 渲染及布局原理</h1> <span class="post-meta"> <time class="post-date" datetime="2016-11-29">Nov 29, 2016</time> <span class="post-author"> &bull; in WebNative</span> </span> </header> <div class="post-content"> <p>接着上一篇博客 <a href="http://code.liqingyao.com/samurai-native-parse-workflow/">Samurai-Native 模板及样式解析原理</a></p> <h2 id="render-workflow">Render Workflow</h2> <h3 id="stylesheet">分配 StyleSheet</h3> <p>这里的分配 styleSheet 是为 domTree 上的每个节点选择应用于自身的样式。在开始渲染 workflow 之前，先来回顾一下剥离了 Samurai CSS 解析内部继承关系之后的关键类图，同时弄明白 CSS 解析部分关键类之间的相互协作关系，也就明白了为什么需要分配 styleSheet 这一个步骤。</p> <p><img src="http://code.liqingyao.com/images/samurai-css-class-structure.png" /></p> <p>类图中间的 <code class="highlighter-rouge">SamuraiCSSStyleSheet</code> 是与 domTree 解析、renderTree 渲染等模块相连接的类。在解析样式时，他会调用 <code class="highlighter-rouge">SamuraiCSSRuleParser</code> 单例的解析方法，把解析得到的 <code class="highlighter-rouge">KatanaOutput</code> 数据结构中的规则表添加到 <code class="highlighter-rouge">SamuraiCSSRuleSet</code> 对象中</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">-</span> <span class="p">(</span><span class="no">BOOL</span><span class="p">)</span><span class="n">parse</span>
<span class="p">{</span>
    <span class="n">_output</span> <span class="o">=</span> <span class="p">[[</span><span class="no">SamuraiCSSParser</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="n">parseStylesheet</span><span class="ss">:self</span><span class="p">.</span><span class="nf">resContent</span><span class="p">];</span>
    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="nf">ruleSet</span> <span class="n">addStyleRules</span><span class="ss">:&amp;</span><span class="n">_output</span><span class="o">-&gt;</span><span class="n">stylesheet</span><span class="o">-&gt;</span><span class="n">rules</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure> <p>添加方法中，先创建一个 <code class="highlighter-rouge">SamuraiCSSRule</code> 规则对象，然后按照规则的匹配属性选择是 idRules、tagRules、classRules，还是其他类型的规则，放到相应的集合中。</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">-</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">addStyleRule</span><span class="p">:(</span><span class="no">KatanaStyleRule</span> <span class="o">*</span><span class="p">)</span><span class="n">rule</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">unsigned</span> <span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">selectors</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="no">KatanaSelector</span> <span class="o">*</span> <span class="n">selector</span> <span class="o">=</span> <span class="n">rule</span><span class="o">-&gt;</span><span class="n">selectors</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="no">SamuraiCSSRule</span> <span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="no">SamuraiCSSRule</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithRule</span><span class="ss">:rule</span> <span class="n">selector</span><span class="ss">:selector</span> <span class="n">position</span><span class="ss">:_ruleSeed</span><span class="o">++</span><span class="p">];</span>
        <span class="no">BOOL</span> <span class="n">found</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">findBestRuleSetAndAddWithSelector</span><span class="ss">:selector</span> <span class="n">ruleData</span><span class="ss">:data</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span> <span class="no">NO</span> <span class="o">==</span> <span class="n">found</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="nf">privateUniversalRules</span> <span class="n">addObject</span><span class="ss">:data</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure> <p>domTree 在为每个节点选择样式时，调用 <code class="highlighter-rouge">SamuraiCSSRuleCollector</code> 的方法在集合中为指定节点选择规则</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">-</span> <span class="p">(</span><span class="no">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="n">collectFromRuleSet</span><span class="p">:(</span><span class="no">SamuraiCSSRuleSet</span> <span class="o">*</span><span class="p">)</span><span class="n">ruleSet</span> <span class="n">forElement</span><span class="p">:(</span><span class="nb">id</span><span class="o">&lt;</span><span class="no">SamuraiCSSProtocol</span><span class="o">&gt;</span><span class="p">)</span><span class="n">element</span><span class="p">;</span></code></pre></figure> <p>在过程中可以发现，Katana Parser 只是扮演解析的工作，即把样式表转换为键值对词典，保存的内容是字符串形式的样式，那么接下来需要做的两件事就是样式选择器和转化器。转化器的实现在建立 renderTree 的过程中完成。</p> <p>接下来看一下样式选择器的工作流程</p> <p><img src="http://code.liqingyao.com/images/samurai-apply-style-timeline.png" /></p> <p>分配 styleSheet 同样是从 worklet 的工厂方法发起，实际调用的 <code class="highlighter-rouge">SamuraiHtmlDocumentWorklet_60ApplyStyleTree</code> 方法</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">-</span> <span class="p">(</span><span class="no">BOOL</span><span class="p">)</span><span class="n">processWithContext</span><span class="p">:(</span><span class="no">SamuraiHtmlDocument</span> <span class="o">*</span><span class="p">)</span><span class="n">document</span></code></pre></figure> <p>内部对 <code class="highlighter-rouge">document.domTree</code> 递归，为每个 <code class="highlighter-rouge">domNode</code> 和 <code class="highlighter-rouge">domNode.shadowRoot</code> 调用</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">-</span> <span class="p">(</span><span class="no">NSMutableDictionary</span> <span class="o">*</span><span class="p">)</span><span class="n">computeStyleForDomNode</span><span class="p">:(</span><span class="no">SamuraiHtmlDomNode</span> <span class="o">*</span><span class="p">)</span><span class="n">domNode</span></code></pre></figure> <p>选择样式集合，存储到 <code class="highlighter-rouge">domNode.computedStyle</code> 里，为下一步渲染时的样式转化器使用。</p> <p>选择器主要的工作是处理继承关系和多种属性的集成，在上面方法的内部，实际上依次处理了以下样式：</p> <ul> <li>默认样式值 <code class="highlighter-rouge">[SamuraiHtmlUserAgent sharedInstance].defaultCSSValue</code></li> <li>默认继承的样式：在 <code class="highlighter-rouge">[SamuraiHtmlUserAgent sharedInstance].defaultCSSInherition</code> 中选择父类有的样式</li> <li>默认属性样式：在 <code class="highlighter-rouge">[SamuraiHtmlUserAgent sharedInstance].defaultDOMAttributedStyle</code> 中选择节点属性中存在的样式</li> <li>内联样式：直接调用 CSS 解析器解析样式属性的内容</li> </ul> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">NSDictionary</span> <span class="o">*</span> <span class="n">attrStyle</span> <span class="o">=</span> <span class="p">[[</span><span class="no">SamuraiCSSParser</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="n">parseDictionary</span><span class="ss">:domNode</span><span class="p">.</span><span class="nf">attrStyle</span><span class="p">];</span></code></pre></figure> <ul> <li>匹配样式：之前 styleTree 解析出的匹配当前节点的样式</li> </ul> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">NSDictionary</span> <span class="o">*</span> <span class="n">matchedStyle</span> <span class="o">=</span> <span class="p">[</span><span class="n">domNode</span><span class="p">.</span><span class="nf">document</span><span class="p">.</span><span class="nf">styleTree</span> <span class="n">queryForObject</span><span class="ss">:domNode</span><span class="p">];</span></code></pre></figure> <ul> <li>继承样式：继承的样式享有最高的优先级，在父节点的 <code class="highlighter-rouge">computedStyle</code> 中选出当前节点继承的样式</li> </ul> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">NSObject</span> <span class="o">*</span> <span class="n">inheritedValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">domNode</span><span class="p">.</span><span class="nf">parent</span><span class="p">.</span><span class="nf">computedStyle</span> <span class="n">objectForKey</span><span class="ss">:key</span><span class="p">];</span></code></pre></figure> <p>另一款 NetSurf 浏览器 的 LibCSS 解析器具备解析和选择的能力，并且内部采用的数据结构占内存更小、选择器速度更快，但缺点是把上层对象做的事放到底层做，而且依赖外部库，代码的扩展性稍弱。两个解析器各有利弊，看如何取舍。</p> <h3 id="rendertree">生成 RenderTree</h3> <p>renderTree 是渲染过程中的核心，在这一步中会逐步构建出一棵完整的 renderTree。首先看一下相关类的继承和调用关系，把握一个宏观方向。</p> <p><img src="http://code.liqingyao.com/images/samurai-render-class-structure.png" /></p> <p>类图中祖先类 <code class="highlighter-rouge">SamuraiTreeNode</code> 的两路分支，一路 <code class="highlighter-rouge">SamuraiDomNode</code> 掌管着 domTree，可以看到类属性 document 持有解析的源头文档对象，通过 <code class="highlighter-rouge">- (void)attach:(SamuraiDocument *)document</code> 和 <code class="highlighter-rouge">- (void)detach()</code> 绑定和解绑文档，另一个 <code class="highlighter-rouge">computesStyle</code> 属性保存节点的样式词典，同时一个 domNode 还关联着 <code class="highlighter-rouge">shadowRoot</code>，如果自己是 shadow 节点那么还有一个 <code class="highlighter-rouge">shadowHost</code> 属性。</p> <p><code class="highlighter-rouge">SamuraiTreeNode</code> 的另一路分支 <code class="highlighter-rouge">SamuraiRenderObject</code> 掌管着 renderTree，与 domTree 不同的是 renderTree 作用与渲染、样式计算、视图创建和布局计算，这点从数据结构中就能体现，<code class="highlighter-rouge">SamuraiRenderObejct</code> 弱引用生成自己的 domNode，持有一个用于计算渲染样式的 <code class="highlighter-rouge">SamuraiRenderStyle</code> 对象、一个实际的原生控件视图、和一个用于计算视图布局的 <code class="highlighter-rouge">SamuraiLayoutObject</code> 对象，相应的有绑定 domNode、style 和计算样式、视图尺寸的一些方法。</p> <p>了解了 <code class="highlighter-rouge">SamuraiRenderObject</code> 的横向关系网之后，来看一下纵向继承关系。<code class="highlighter-rouge">SamuraiRenderObject</code> 的子类 <code class="highlighter-rouge">SamuraiHtmlRenderObject</code> 在内部重写了父类的大多数方法，他的四个子类是 renderTree 构建时的实体类，根据 domNode 的类型和在 domTree 中的层级进行路由选择，</p> <ul> <li><code class="highlighter-rouge">SamuraiHtmlRenderViewPort</code>：document 类型的节点，一般是唯一的，指代浏览器或屏幕对象</li> <li><code class="highlighter-rouge">SamuraiHtmlRenderContainer</code>：domTree 中的非叶子节点和 shadowTree 的根节点</li> <li><code class="highlighter-rouge">SamuraiHtmlRenderElement</code>：domTree 中所有视图层级非隐藏的叶子节点</li> <li><code class="highlighter-rouge">SamuraiHtmlRenderText</code>：domTree 中所有 text 类型的节点</li> </ul> <p>之所以需要上面的路由规则来对每个节点分类，一是在构建 renderTree 时可以做一些视图层级上的优化，二是便于接下来计算布局时的分类讨论，有点类似于 stackView 的概念，这一点放在后面分析。</p> <p>宏观把握之后，再来看关键路径的方法调用就容易理解了</p> <p><img src="http://code.liqingyao.com/images/samurai-build-render-timeline.png" /></p> <p>作为渲染流程中的最后一步，同样是通过触发 <code class="highlighter-rouge">SamuraiHtmlDocumentWorklet_70BuildRenderTree</code> 的入口方法</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">-</span> <span class="p">(</span><span class="no">BOOL</span><span class="p">)</span><span class="n">processWithContext</span><span class="p">:(</span><span class="no">SamuraiHtmlDocument</span> <span class="o">*</span><span class="p">)</span><span class="n">document</span></code></pre></figure> <p>先根据 domNode 的类型创建对应的 renderObject，对 document 类型节点创建 <code class="highlighter-rouge">SamuraiHtmlRenderViewPort</code> 对象，对 text 类型节点创建 <code class="highlighter-rouge">SamuraiHtmlRenderText</code> 对象。容器和元素对象的创建条件稍微复杂一些，</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">-</span> <span class="p">(</span><span class="no">SamuraiHtmlRenderObject</span> <span class="o">*</span><span class="p">)</span><span class="n">renderDomNodeElement</span><span class="p">:(</span><span class="no">SamuraiHtmlDomNode</span> <span class="o">*</span><span class="p">)</span><span class="n">domNode</span> <span class="n">forContainer</span><span class="p">:(</span><span class="no">SamuraiHtmlRenderObject</span> <span class="o">*</span><span class="p">)</span><span class="n">container</span> <span class="n">inDocument</span><span class="p">:(</span><span class="no">SamuraiHtmlDocument</span> <span class="o">*</span><span class="p">)</span><span class="n">document</span>
<span class="p">{</span>
    <span class="no">SamuraiHtmlRenderStyle</span> <span class="o">*</span> <span class="n">thisStyle</span> <span class="o">=</span> <span class="p">[</span><span class="no">SamuraiHtmlRenderStyle</span> <span class="n">renderStyle</span><span class="ss">:domNode</span><span class="p">.</span><span class="nf">computedStyle</span><span class="p">];</span>
    <span class="no">SamuraiHtmlRenderObject</span> <span class="o">*</span> <span class="n">thisObject</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">;</span>

    <span class="no">CSSViewHierarchy</span> <span class="n">viewHierarchy</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisStyle</span> <span class="n">computeViewHierarchy</span><span class="ss">:CSSViewHierarchy_Inherit</span><span class="p">];</span>
    <span class="n">switch</span> <span class="p">(</span> <span class="n">viewHierarchy</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="no">CSSViewHierarchy_Hidden</span><span class="p">:</span>
        <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="no">CSSViewHierarchy_Branch</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span> <span class="no">SamuraiHtmlDomNode</span> <span class="o">*</span> <span class="n">childDom</span> <span class="k">in</span> <span class="n">domNode</span><span class="p">.</span><span class="nf">childs</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="p">[</span><span class="nb">self</span> <span class="n">renderDomNode</span><span class="ss">:childDom</span> <span class="n">forContainer</span><span class="ss">:container</span> <span class="n">inDocument</span><span class="ss">:document</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="no">CSSViewHierarchy_Leaf</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="n">thisObject</span> <span class="o">=</span> <span class="p">[</span><span class="no">SamuraiHtmlRenderElement</span> <span class="n">renderObjectWithDom</span><span class="ss">:domNode</span> <span class="n">andStyle</span><span class="ss">:thisStyle</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="no">CSSViewHierarchy_Tree</span><span class="p">:</span>
        <span class="p">{</span>
            <span class="n">thisObject</span> <span class="o">=</span> <span class="p">[</span><span class="no">SamuraiHtmlRenderContainer</span> <span class="n">renderObjectWithDom</span><span class="ss">:domNode</span> <span class="n">andStyle</span><span class="ss">:thisStyle</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">thisObject</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span> <span class="no">SamuraiHtmlDomNode</span> <span class="o">*</span> <span class="n">childDom</span> <span class="k">in</span> <span class="n">domNode</span><span class="p">.</span><span class="nf">childs</span> <span class="p">)</span>
                <span class="p">{</span>
                    <span class="p">[</span><span class="nb">self</span> <span class="n">renderDomNode</span><span class="ss">:childDom</span> <span class="n">forContainer</span><span class="ss">:thisObject</span> <span class="n">inDocument</span><span class="ss">:document</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
        <span class="ss">default:
        </span><span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">thisObject</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <p>通过样式对象计算自己的视图层级，处理继承关系，之后根据视图层级选择创建 <code class="highlighter-rouge">SamuraiHtmlRenderContainer</code> 对象还是 <code class="highlighter-rouge">SamuraiHtmlRenderElement</code> 对象。</p> <p>接下调用 <code class="highlighter-rouge">SamuraiHtmlRenderStyle</code> 的接口方法计算 renderNode 的每个样式属性，完成后根据 <code class="highlighter-rouge">SamuraiHtmlRenderObejct</code> 的具体类型创建相应的 <code class="highlighter-rouge">SamuraiHtmlLayoutObject</code>，并绑定到 <code class="highlighter-rouge">renderNode.layout</code> 属性上，为下面的布局计算做准备。</p> <h2 id="view-workflow">View Workflow</h2> <h3 id="section">生成视图</h3> <p>到这里为止，资源加载流程全部完毕，包括解析和创建 renderTree。Samurai-Native 在资源加载过程中设置了一些内部状态</p> <ul> <li>加载中</li> <li>加载完成</li> <li>加载失败</li> <li>取消加载</li> </ul> <p>在不同的时间节点会调用 <code class="highlighter-rouge">SamuraiTemplate</code> 的</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">-</span> <span class="p">(</span><span class="no">BOOL</span><span class="p">)</span><span class="n">changeState</span><span class="p">:(</span><span class="no">TemplateState</span><span class="p">)</span><span class="n">newState</span></code></pre></figure> <p>更新状态流转情况，之后随即对资源的响应者调用</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">-</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">handleTemplate</span><span class="p">:(</span><span class="no">SamuraiTemplate</span> <span class="o">*</span><span class="p">)</span><span class="n">template</span></code></pre></figure> <p>实际上，只有状态是加载完成时才有实际的执行内容，也就是根据 renderTree 的结构创建视图</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">-</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">handleTemplate</span><span class="p">:(</span><span class="no">SamuraiTemplate</span> <span class="o">*</span><span class="p">)</span><span class="n">template</span>
<span class="p">{</span>   
    <span class="k">if</span> <span class="p">(</span> <span class="n">template</span><span class="p">.</span><span class="nf">loading</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="p">[</span><span class="nb">self</span> <span class="n">onTemplateLoading</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">template</span><span class="p">.</span><span class="nf">loaded</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="p">[</span><span class="n">template</span><span class="p">.</span><span class="nf">document</span> <span class="n">configureForView</span><span class="ss">:self</span><span class="p">];</span>

        <span class="no">SamuraiRenderObject</span> <span class="o">*</span> <span class="n">rootRender</span> <span class="o">=</span> <span class="n">template</span><span class="p">.</span><span class="nf">document</span><span class="p">.</span><span class="nf">renderTree</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="p">(</span> <span class="n">rootRender</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="nb">self</span><span class="p">.</span><span class="nf">renderer</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span> <span class="no">SamuraiRenderObject</span> <span class="o">*</span> <span class="n">childRender</span> <span class="k">in</span> <span class="p">[</span><span class="n">rootRender</span><span class="p">.</span><span class="nf">childs</span> <span class="n">reverseObjectEnumerator</span><span class="p">]</span> <span class="p">)</span>
                <span class="p">{</span>
                    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="nf">renderer</span> <span class="n">appendNode</span><span class="ss">:childRender</span><span class="p">];</span>
                    <span class="no">UIView</span> <span class="o">*</span> <span class="n">childView</span> <span class="o">=</span> <span class="p">[</span><span class="n">childRender</span> <span class="n">createViewWithIdentifier</span><span class="ss">:nil</span><span class="p">];</span>

                    <span class="k">if</span> <span class="p">(</span> <span class="n">childView</span> <span class="p">)</span>
                    <span class="p">{</span>
                        <span class="p">[</span><span class="nb">self</span> <span class="n">addSubview</span><span class="ss">:childView</span><span class="p">];</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="p">[</span><span class="nb">self</span> <span class="n">onTemplateLoaded</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="p">[</span><span class="nb">self</span> <span class="n">onTemplateFailed</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">template</span><span class="p">.</span><span class="nf">failed</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="p">[</span><span class="nb">self</span> <span class="n">onTemplateFailed</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">template</span><span class="p">.</span><span class="nf">cancelled</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="p">[</span><span class="nb">self</span> <span class="n">onTemplateCancelled</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure> <p>上面的代码从 renderTree 的根节点开始递归调用 <code class="highlighter-rouge">SamuraiHtmlRenderObject</code> 的方法构造视图树</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">-</span> <span class="p">(</span><span class="no">UIView</span> <span class="o">*</span><span class="p">)</span><span class="n">createViewWithIdentifier</span><span class="p">:(</span><span class="no">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">identifier</span></code></pre></figure> <p>上面方法的内部首先会根据 <code class="highlighter-rouge">renderNode.viewClass</code> 的类型创建视图，然后对视图调用 <code class="highlighter-rouge">UIView+Html</code> 的扩展方法</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">-</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">html_applyDom</span><span class="p">:(</span><span class="no">SamuraiHtmlDomNode</span> <span class="o">*</span><span class="p">)</span><span class="n">dom</span></code></pre></figure> <p>把 domNode 上的事件绑定到视图上，比如点击、滑动、长按等。</p> <p>最后，根据 <code class="highlighter-rouge">renderNode.zIndex</code> 对各子节点调整视图层级，</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">if</span> <span class="p">(</span> <span class="nb">self</span><span class="p">.</span><span class="nf">childs</span> <span class="o">&amp;&amp;</span> <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="nf">childs</span> <span class="n">count</span><span class="p">]</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="no">NSMutableArray</span> <span class="o">*</span> <span class="n">subRenderers</span> <span class="o">=</span> <span class="p">[</span><span class="no">NSMutableArray</span> <span class="n">nonRetainingArray</span><span class="p">];</span>
    
    <span class="p">[</span><span class="n">subRenderers</span> <span class="n">addObjectsFromArray</span><span class="ss">:self</span><span class="p">.</span><span class="nf">childs</span><span class="p">];</span>
    <span class="p">[</span><span class="n">subRenderers</span> <span class="n">sortUsingComparator</span><span class="ss">:^</span><span class="no">NSComparisonResult</span><span class="p">(</span><span class="no">SamuraiHtmlRenderObject</span> <span class="o">*</span> <span class="n">obj1</span><span class="p">,</span> <span class="no">SamuraiHtmlRenderObject</span> <span class="o">*</span> <span class="n">obj2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">obj1</span><span class="p">.</span><span class="nf">zIndex</span> <span class="o">&lt;</span> <span class="n">obj2</span><span class="p">.</span><span class="nf">zIndex</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="no">NSOrderedAscending</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">obj1</span><span class="p">.</span><span class="nf">zIndex</span> <span class="o">&gt;</span> <span class="n">obj2</span><span class="p">.</span><span class="nf">zIndex</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="no">NSOrderedDescending</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="no">NSOrderedSame</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}];</span>
    
    <span class="k">for</span> <span class="p">(</span> <span class="no">SamuraiHtmlRenderObject</span> <span class="o">*</span> <span class="n">subRenderer</span> <span class="k">in</span> <span class="n">subRenderers</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">subRenderer</span><span class="p">.</span><span class="nf">view</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="p">[</span><span class="n">subRenderer</span><span class="p">.</span><span class="nf">view</span><span class="p">.</span><span class="nf">superview</span> <span class="n">bringSubviewToFront</span><span class="ss">:subRenderer</span><span class="p">.</span><span class="nf">view</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure> <p>具体方法调用可以参考创建视图的 timeline</p> <p><img src="http://code.liqingyao.com/images/samurai-view-timeline.png" /></p> <p>接下来看一下在视图上应用样式和布局的时机和中间类的流转关系。</p> <p><img src="http://code.liqingyao.com/images/samurai-view-class-structure.png" /></p> <p>Samurai-Native 采用的方案是对几乎所有的 <code class="highlighter-rouge">UIKit</code> 类进行扩展，各个视图类分别支持应用样式和应用布局尺寸的方法，而根据视图的类型动态选择相应方法是通过两个工厂类来实现。<code class="highlighter-rouge">UIKit</code> 的 <code class="highlighter-rouge">Samurai</code> 扩展类作为基础部件都存放在 <code class="highlighter-rouge">samurai-framework</code> 的 <code class="highlighter-rouge">samurai-view</code> 目录下，每个类别都会去重写 <code class="highlighter-rouge">NSObject+Renderer</code> 的扩展方法，</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">-</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">applyDom</span><span class="p">:(</span><span class="no">SamuraiDomNode</span> <span class="o">*</span><span class="p">)</span><span class="n">dom</span><span class="p">;</span>	
<span class="o">-</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">applyStyle</span><span class="p">:(</span><span class="no">SamuraiRenderStyle</span> <span class="o">*</span><span class="p">)</span><span class="n">style</span><span class="p">;</span>
<span class="o">-</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">applyFrame</span><span class="p">:(</span><span class="no">CGRect</span><span class="p">)</span><span class="n">frame</span><span class="p">;</span>	</code></pre></figure> <p>另一方面，<code class="highlighter-rouge">UIKit</code> 的 <code class="highlighter-rouge">Html</code> 扩展类都存放在 <code class="highlighter-rouge">samurai-webcore</code> 目录下，<code class="highlighter-rouge">html-component</code> 目录下存放系统控件的扩展类，<code class="highlighter-rouge">html-element</code> 目录下存放 html 元素的扩展类，这些类都继承自 <code class="highlighter-rouge">UIView</code>，而且分别重写了 <code class="highlighter-rouge">NSObject+HtmlSupport</code> 的扩展方法</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">-</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">html_applyDom</span><span class="p">:(</span><span class="no">SamuraiHtmlDomNode</span> <span class="o">*</span><span class="p">)</span><span class="n">dom</span><span class="p">;</span>
<span class="o">-</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">html_applyStyle</span><span class="p">:(</span><span class="no">SamuraiHtmlRenderStyle</span> <span class="o">*</span><span class="p">)</span><span class="n">style</span><span class="p">;</span>
<span class="o">-</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">html_applyFrame</span><span class="p">:(</span><span class="no">CGRect</span><span class="p">)</span><span class="n">frame</span><span class="p">;</span>	</code></pre></figure> <p>比如，对 <code class="highlighter-rouge">UILabel</code> 调用 <code class="highlighter-rouge">[self.view html_applyStyle:self.style];</code> 时，首先依次向上调用父类的相应方法直到 <code class="highlighter-rouge">NSObject+HtmlSupport</code>，而 <code class="highlighter-rouge">NSObject+HtmlSupport</code> 的 <code class="highlighter-rouge">html_applyStyle</code> 方法中实际是调用了 <code class="highlighter-rouge">NSObject+Renderer</code> 的 <code class="highlighter-rouge">applyStyle</code> 方法，并通过工厂方法作为路由根据实际的视图类去调方法，最后再依次反方向回路，像半个回字形。</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">-</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">html_applyDom</span><span class="p">:(</span><span class="no">SamuraiHtmlDomNode</span> <span class="o">*</span><span class="p">)</span><span class="n">dom</span>
<span class="p">{</span>
	<span class="p">[</span><span class="nb">self</span> <span class="n">applyDom</span><span class="ss">:dom</span><span class="p">];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">html_applyStyle</span><span class="p">:(</span><span class="no">SamuraiHtmlRenderStyle</span> <span class="o">*</span><span class="p">)</span><span class="n">style</span>
<span class="p">{</span>
	<span class="p">[</span><span class="nb">self</span> <span class="n">applyStyle</span><span class="ss">:style</span><span class="p">];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">html_applyFrame</span><span class="p">:(</span><span class="no">CGRect</span><span class="p">)</span><span class="n">newFrame</span>
<span class="p">{</span>
	<span class="p">[</span><span class="nb">self</span> <span class="n">applyFrame</span><span class="ss">:newFrame</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure> <p><code class="highlighter-rouge">SamuraiHtmlRenderWorklet_20UpdateStyle</code> 和 <code class="highlighter-rouge">SamuraiHtmlRenderWorklet_30UpdateFrame</code> 两个 worklet 中分别调用上述方法对视图应用样式和布局，</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="p">[</span><span class="n">renderObject</span><span class="p">.</span><span class="nf">view</span> <span class="n">html_applyStyle</span><span class="ss">:renderObject</span><span class="p">.</span><span class="nf">style</span><span class="p">];</span>
<span class="p">[</span><span class="n">renderObject</span><span class="p">.</span><span class="nf">view</span> <span class="n">html_applyFrame</span><span class="ss">:renderObject</span><span class="p">.</span><span class="nf">layout</span><span class="p">.</span><span class="nf">frame</span><span class="p">];</span></code></pre></figure> <p>这两个 worklet 又被分别封装在 <code class="highlighter-rouge">SamuraiHtmlRenderObejct</code> 的方法中，</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">-</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">relayout</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span> <span class="kp">nil</span> <span class="o">==</span> <span class="n">_relayoutFlow</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="n">_relayoutFlow</span> <span class="o">=</span> <span class="p">[</span><span class="no">SamuraiHtmlRenderWorkflow_UpdateFrame</span> <span class="n">workflowWithContext</span><span class="ss">:self</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="p">[</span><span class="n">_relayoutFlow</span> <span class="n">process</span><span class="p">];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="n">restyle</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span> <span class="kp">nil</span> <span class="o">==</span> <span class="n">_restyleFlow</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="n">_restyleFlow</span> <span class="o">=</span> <span class="p">[</span><span class="no">SamuraiHtmlRenderWorkflow_UpdateStyle</span> <span class="n">workflowWithContext</span><span class="ss">:self</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="p">[</span><span class="n">_restyleFlow</span> <span class="n">process</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure> <p>查看 <code class="highlighter-rouge">- (void)restyle</code> 的主调方法，主要在几种情况下会触发对视图更新样式</p> <ul> <li>UICollectionView 和 UITableView 更新 cell 或获取 cell 信息时触发</li> <li>UIView 或 UIViewController 页面初始化或重新加载时触发</li> </ul> <p>查看 <code class="highlighter-rouge">- (void)relayout</code> 的主调方法，主要在几种情况下会触发对视图更新布局</p> <ul> <li>UICollectionView 和 UITableView 显示前触发</li> <li>UIView 或 UIViewController 页面初始化或重新加载时触发</li> </ul> <aside class="share"> <span>Share this to</span> <a href="http://twitter.com/share?text=Samurai-Native 渲染及布局原理&amp;url=http://code.liqingyao.com/samurai-native-render-workflow/&amp;hashtags=web,dev,blog,soudev&amp;via=liqingyao"> <i class="fa fa-twitter-square"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?u=http://code.liqingyao.com/samurai-native-render-workflow/"> <i class="fa fa-facebook-square"></i> </a> <a href="https://plus.google.com/share?url=http://code.liqingyao.com/samurai-native-render-workflow/"> <i class="fa fa-google-plus-square"></i> </a> <a href="http://www.linkedin.com/shareArticle?mini=true&url=http://code.liqingyao.com/samurai-native-render-workflow/&title=Samurai-Native 渲染及布局原理&summary=Li Qingyao&source=http://code.liqingyao.com"> <i class="fa fa-linkedin-square"></i> </a> <!-- <a href="https://plus.google.com/share?url=http://code.liqingyao.com/samurai-native-render-workflow/"> <i class="fa fa-wechat"></i> </a> <a href="http://www.linkedin.com/shareArticle?mini=true&url=http://code.liqingyao.com/samurai-native-render-workflow/&title=Samurai-Native 渲染及布局原理&summary=Li Qingyao&source=http://code.liqingyao.com"> <i class="fa fa-weibo"></i> </a> <a href="https://www.qq.com/share?url=http://code.liqingyao.com/samurai-native-render-workflow/"> <i class="fa fa-qq"></i> </a> --> </aside> <hr> <aside id="comments" class="disqus"> <h2 class="txt-center">Comments</h2> <div id="disqus_thread"></div> <script type="text/javascript"> var disqus_shortname = 'codeliqingyao'; var disqus_identifier = '/samurai-native-render-workflow'; var disqus_title = 'Samurai-Native 渲染及布局原理'; var disqus_url = 'http://code.liqingyao.com'; /*var disqus_developer = 1;*/ (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); </script> <noscript> Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a> </noscript> </aside> </div> </article> <footer class="footer t-center"> <div class="container"> <div class="social-icons"> <ul class="text-left"> <li><a href="https://github.com/liqingyao" target="_blank"><i class="fa fa-github"></i></a></li> <li><a href="http://weibo.com/leeleeannie" target="_blank"><i class="fa fa-weibo"></i></a></li> <li><a href="https://www.linkedin.com/in/liqingyao" target="_blank"><i class="fa fa-linkedin"></i></a></li> <li><a href="mailto:qingyao.li@yahoo.com" target="_blank"><i class="fa fa-envelope-o"></i></a></li> </ul> </div> <small>&copy; 2016 Li Qingyao. Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> and <i class="icon icon-heart"></i></small> <small>by <a href="http://nandomoreira.me" target="_blank">nandomoreira.me</a></small> </div> </footer> </main> </body> </html></body></html>
<!--
// # Zetsu Jekyll theme - https://github.com/nandomoreriame/zetsu/
// by nandomoreira.me
-->
